# day1(10.30)
## 数组基础部分
重点:: **<font style="color:rgb(44, 62, 80);">数组的元素是不能删的，只能被覆盖。</font>**

## <font style="color:rgb(44, 62, 80);">题目</font>
### lc704二分查找
1. 把握条件

到底是小于  还是小于等于  怎么决定?

关键在于明确区间的定义 到底是[l, r**) ** 还是[l ,r** ]**

写法一: [ ]

```java
public int search(int[] nums, int target) {
     if (target < nums[0] || target > nums[nums.length - 1]) return -1;
    
    int l = 0, r = nums.length - 1;
    while(l <= r){
        int mid = l + ((r - l)>>1);
        if(nums[mid] == target) return mid;
        else if(nums[mid] > target) r = mid + 1;
        else l = mid - 1;
    }
    return -1;
}
```

写法二: **[ )**

```java
public int search(int[] nums, int target) {
     if (target < nums[0] || target > nums[nums.length - 1]) return -1;

    int l = 0, r = nums.length;
    while(l < r){
        int mid = l + ((r - l) >>1);
        if(nums[mid] == target) return mid;
        else if(nums[mid] > target) r = m;
        else l = m + 1;
    }
    return -1;
}
```

### lc27移除元素
使用快慢指针  目的是使用一层for 来干原本两个for的事

fast快指针代表 寻找新数组需要的元素 也就是出了要删除的元素之外的所有其他元素

slow慢指针代表 新数组的下标

这样快指针获取到的值 赋给慢指针就行

当快指针指向的元素不等于要删除的  就是新数组所需要的

```java
public int removeElement(int[] nums, int val) {
    int s = 0;
    for(int f = 0; f < nums.length; f++){
        if(nums[f] != val){
            nums[s] = nums[f];
            s++;
        }
    }
    return s;
}
```

### lc977 有序数组的平方
一个有序数组 也有负数 比如

-5	1	2	3

给他开平方之后返回小到大的排列

因为含有负数 所以开平方之后 最大的元素一定分布在两边 



循环条件 只要i <= j的时候就一直继续



```java
public int[] sortedSquares(int[] nums) {

    int l = 0, r = nums.length - 1, k = nums.length - 1;
    wwhile(l <= r){
        if(nums[l] * nums[l] > nums[r] * nums[r]){
            res[k] = nums[l] * nums[l];
            k--;
            l++;
        }else{
            res[k] = nums[r] * nums[r];
            k--;
            r--;
        }
        
    }
    return res;
}

```

注意:

l 是数组左边界   r 是有边界  j 是结果集数组的下标 设置为原本数组的右边届 往左走<--

左右边界对应的数平方 谁大就取谁

取到左边时候 左边要向右走 指针++

取到右边时候 右边届要想左走 指针--

# day2 
### lc209 长度最小的子数组
> <font style="color:rgb(44, 62, 80);">给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</font>
>
> <font style="color:rgb(44, 62, 80);">示例：</font>
>
> + <font style="color:rgb(44, 62, 80);">输入：s = 7, nums = [2,3,1,2,4,3]</font>
> + <font style="color:rgb(44, 62, 80);">输出：2</font>
> + <font style="color:rgb(44, 62, 80);">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</font>
>

**暴力解法:**

两个for循环, 不断地找符合条件的子数组,但是时间复杂度是<font style="color:rgb(44, 62, 80);">O(n^2)  但是在最后leetcode跟新了数据 这种很明显超时了.</font>

<font style="color:rgb(44, 62, 80);"></font>

**<font style="color:rgb(44, 62, 80);">滑动窗口(双指针):</font>**

![](https://cdn.nlark.com/yuque/0/2024/gif/26344032/1730450339109-ce4a365b-6c30-4a67-abb9-f0c300c2332c.gif)

**<font style="color:rgb(44, 62, 80);"></font>**

<font style="color:rgb(44, 62, 80);">滑动窗口就是不断的调整子序列的起点和终点 直到得出想要的结果</font>

<font style="color:rgb(44, 62, 80);"></font>

<font style="color:rgb(44, 62, 80);">俩指针</font>

<font style="color:rgb(44, 62, 80);">i 起点  j 终点  起点和终点最开始都在数组的第一个元素位置</font>

<font style="color:rgb(44, 62, 80);">先固定i  移动j 直到找到满足sum  满足了 就停止j终点</font>

<font style="color:rgb(44, 62, 80);">此时移动i起点 找到最短满足的  如果出现小于目标值的情况 那么固定i   j继续移动 </font>

```java
public int minSubArrayLen(int s, int[] nums){

    int l = 0, sum = 0, res = Integer.MAX_VALUE;

    for(int r = 0; r < nums.length; r++){
        sum += nums[r];
        while(sum >= s){
            res = Math.min(res, r - l + 1);
            sum -= nums[l++];
        }
    }
    return res == Integer.MAX_VALUE ? 0 : res;
}
```

### lc59螺旋矩阵I
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个正整数 </font>`<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">n</font>`<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，生成一个包含</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>`<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">1</font>`<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">到 </font>`<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">n</font><sup><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">2</font></sup>`<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 所有元素，且元素按顺时针顺序螺旋排列的 </font>`<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">n x n</font>`<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">正方形矩阵</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>`<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">matrix</font>`<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font>
>

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1730451011887-d7a330ac-7e19-4c58-be4c-33669d852ef1.png)



**本题关键在于边界条件的处理  也就是四方形的四个角怎么处理**

****

遵循一个不变量 到底是[ ]   还是[ ) 

如果[ )  也就是在便利一条边时候 只要边的起点   不要边的终点  作为下一条的起点



题目输入n  n就是 代表矩阵的大小 比如n = 4 那就返回4*4的矩阵

那么螺旋转圈次数就是n / 2次

如果n是奇数 除以2 除不尽剩余一个 

因为每一圈的 起点都不算固定的  所以for循环的i 不可能是固定

****

```java
 public static int[][] generateMatrix(int n) {
        int[][] arr = new int[n][n];
        int startX = 0, startY = 0, offset = 1,loop = 1,count = 1,x,y;
        while (loop <= n / 2){
            for(y = startY; y < n - offset; y++) arr[startX][y] = count++;
            for(x = startX; x < n - offset; x++) arr[x][y] = count++;
            for( ; y > startY; y--) arr[x][y] = count++;
            for( ; x > startX; x--) arr[x][y] = count++;
            startX++;
            startY++;
            loop++;
            offset++;
        }
        if(n % 2 == 1) arr[startX][startY] = count;
        return arr;
    }

```

### 前缀和
> <font style="color:rgb(44, 62, 80);">题目描述</font>
>
> <font style="color:rgb(44, 62, 80);">给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。</font>
>
> <font style="color:rgb(44, 62, 80);">输入描述</font>
>
> **<font style="color:rgb(44, 62, 80);">第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。</font>**
>
> <font style="color:rgb(44, 62, 80);">输出描述</font>
>
> <font style="color:rgb(44, 62, 80);">输出每个指定区间内元素的总和。</font>
>

**<font style="color:rgb(44, 62, 80);">思路:</font>**

1. **暴力解法**

有一个区间之后 直接暴力把这个区间的和都累加一遍   但是提交代码提示超时



2. **前缀和**

前缀和就是利用计算过的子数组的和 从而降低区间查询需要累加计算的次数

**在设计计算区间和时候非常有用**

比如要计算vec[i] 在这个数组上的区间和

首先累加 p[i]表示下标0~i的vec累加和

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1730617697773-f833c4aa-f590-4e9a-a017-6e2a735a21d2.png)

计算下标2到5的区间和

<font style="color:rgb(44, 62, 80);"> 区间下标 [2, 5] 的区间和，那么应该是 p[5] - p[1]，而不是 p[5] - p[2]。</font>

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] vec = new int[n]; //原本数组
        int[] p = new int[n];  //原本数组的区间和
        // 计算原本数组的区间和
        int preSum = 0;
        for(int i = 0; i < n; i++){
            vec[i] = sc.nextInt();
            preSum += vec[i];
            p[i] = preSum;
        }
        
        while (sc.hasNextInt()){
            int a = sc.nextInt();
            int b = sc.nextInt();
            int sum = 0;
            if(a == 0) sum = p[b];
            else sum = p[b] - p[a - 1];
            System.out.println(sum);
        }

    }
}

```



### 开发商买土地
> <font style="color:rgb(44, 62, 80);">【题目描述】</font>
>
> <font style="color:rgb(44, 62, 80);">在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。</font>
>
> <font style="color:rgb(44, 62, 80);">现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。</font>
>
> <font style="color:rgb(44, 62, 80);">然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。</font>
>
> <font style="color:rgb(44, 62, 80);">为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。</font>
>
> <font style="color:rgb(44, 62, 80);">注意：区块不可再分。</font>
>



**解法思路:**

本题 要求任意两行或者两列之间的数值之和, 也就是前缀和

先计算出行 列方向的和  然后统计好前n行的和 q[n]  如果要求a行到b行之间的总和 那么就是q[b] - q[a - 1]





将一个二维数组划分为两部分，使得这两部分的和之差最小。

首先计算整个数组的总和 `sum`，然后分别求出每一行和每一列的和，存储在 `horizontal` 和 `vertical` 数组中。

接着，通过累加 `horizontal` 数组中的行和，逐步模拟横向划分，将前几行作为一部分、剩余行作为另一部分。每次划分时，计算当前划分后两部分和的差值，并更新最小差值 `result`。同理，对于纵向划分，累加 `vertical` 数组中的列和，模拟不同的列划分方式，计算两部分的差值，并更新最小差值。最终输出的 `result` 就是所有可能划分方式中两部分和的最小差值。

```java
import java.util.*;

public class Main{
    
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int sum = 0;
        int[][] vec = new int[n][m];
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                vec[i][j] = sc.nextInt();
                sum += vec[i][j];
            }
        }
        
        // 统计每行的和
        int[] rowSum = new int[n];
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                rowSum[i] += vec[i][j];
            }
        }
        
        // 统计每列的和
        int[] colSum = new int[m];
        for(int j = 0; j < m; j++){
            for(int i = 0; i < n; i++){
                colSum[j] += vec[i][j];
            }
        }
        
        int res = Integer.MAX_VALUE;
        
        // 计算行划分的最小差值
        int rowCut = 0;
        for(int i = 0; i < n; i++){
            rowCut += rowSum[i];
            res = Math.min(res, Math.abs(sum - 2 * rowCut));
        }
        
        // 计算列划分的最小差值
        int colCut = 0;
        for(int j = 0; j < m; j++){
            colCut += colSum[j];
            res = Math.min(res, Math.abs(sum - 2 * colCut));
        }
        
        System.out.println(res);
        
        sc.close();
    }
}

```







# day3 链表章节


### 链表基础部分
链表就是通过指针串联在一起的线性结构, 每个节点有两部分组成 分别是数据域 指针域  并且最后一个指针指向null

单链表中的指针只能指向节点的下一个

双链表: 每个节点有两个指针 一个指针指向下一个节点 一个指向上一个节点

循环链表: 首尾相连



定义节点:

```java
public class Node{
    int v;
    Node next;
}
```

**删除节点:**

比如a --> b ---> c ----> d ---> null  如果要删除的b节点 那么

只需要将b节点的next指针指向d即可, c节点会被gc回收

**添加节点:**

在b c中间添加个f 也就是 将b指针指向f  f指针指向c



总结: 

链表的增加和删除都是O1操作,也不会影响到另一个节点



### lc203 移除链表元素
> **<font style="color:rgb(44, 62, 80);">题意：删除链表中等于给定值 val 的所有节点。</font>**
>
> <font style="color:rgb(44, 62, 80);">示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</font>
>
> <font style="color:rgb(44, 62, 80);">示例 2： 输入：head = [], val = 1 输出：[]</font>
>
> <font style="color:rgb(44, 62, 80);">示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]</font>
>

<font style="color:rgb(44, 62, 80);"></font>

<font style="color:rgb(44, 62, 80);">本题删除链表中的元素</font>

也就是让被删除的前一个节点 指向节点的下一个节点就可以了 

但是 如果被删除的节点恰好就是头结点呢?  头节点本身就是第一个节点 不存在前一个节点

**所以可以使用虚拟节点法 重新定义一个虚拟临时节点 指向头结点**

**如果删除的是头结点 那么就可以让临时节点直接指向头结点是下一个节点  最后return 是temp.next**

```java
public Node removeElements(Node head, int val) {
    // 1. 设置虚拟节点
    Node temp = new Node();
    temp.next = head;
    // 2. 当前指针
    Node cur = temp;
    // 便利
    while(cur.next != null){
        if(cur.next.val == val) cur.next = cur.next.next;
        else cur = cur.next;
    }
    return temp.next;
}

```

### lc707 设计链表
> + <font style="color:rgb(44, 62, 80);">get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</font>
> + <font style="color:rgb(44, 62, 80);">addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</font>
> + <font style="color:rgb(44, 62, 80);">addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</font>
> + <font style="color:rgb(44, 62, 80);">addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</font>
> + <font style="color:rgb(44, 62, 80);">deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</font>
>

<font style="color:rgb(44, 62, 80);">这</font>**<font style="color:rgb(44, 62, 80);">个题涵盖了链表的基本操作</font>**

**<font style="color:rgb(44, 62, 80);">头插		尾插	  获取第n个值	第n个节点前插		删除第n个</font>**

<font style="color:rgb(44, 62, 80);">本题的初始化</font>

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val) {
        this.val=val;
    }
}
-----
class MyLinkedList {
     //size存储链表元素的个数
    int size;
    //虚拟头结点
    ListNode head;

    //初始化链表
    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }

    ........
    ........
}
```

1. **获取第n个值**

```java
public int get(int index){
    if(index < 0 || index >= size) return -1;
    Node cur = head;
    for(int i = 0; i <= index; i++) cur = cur.next;
    return cur.val;
}
```

2. 头插

```java
// 头插等价于在第0个元素前添加
public void addAtHead(int val){
    Node newNode = new Node(val);
    newNode.next = head.next;
    head.next = newNode;
    size++;

}
```

3. 尾插

```java
// 尾差等价于在(末尾+1)个元素前面添加
public void addAtTail(int val){
    Node newNode = new Node(val);
    Node cur = head;
    while(cur.next != null) cur = cur.next;

    cur.next = newNode;
    size++;

}
```



4. 在第n个节点前面插入

```java
// 如果index大于链表的总长度 返回空
// 如果index等于链表的长度 就说明是新插入节点的尾巴节点
// 第index节点之前插入一个新节点  假如index = 0, 那就代表新插入的节点是链表的新头结点
public void addAtIndex(int index, int val){
    if(index > size) return;
    if(index < 0) index = 0;
    size++;

    // 找到要插入节点的前一个节点
    Node pred = head;
    for(int i = 0; i < index; i++) pred = pred.next;
    
    Node toAdd = new Node(val);
    toAdd.next = pred.next;
    pred.next = toAdd;
}
```



5. 删除第n个节点

```java
public void delAtIndex(int index){
    if(index < 0 || index >= size) return;
    size--;
    Node pred = head;
    for(int i = 0; i < index; i++) pred = pred.next;
    pred.next = pred.next.next;
}
```

### lc206翻转单链表
> <font style="color:rgb(44, 62, 80);">示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL</font>
>

<font style="color:rgb(44, 62, 80);"></font>

**<font style="color:rgb(44, 62, 80);">写法一: 双指针解法</font>**

**<font style="color:rgb(44, 62, 80);">首先 定义了三个节点变量</font>**

**<font style="color:rgb(44, 62, 80);">pre当前节点的前一个节点 初始化为null  因为翻转之后的链表的尾巴节点应该指向null</font>**

**<font style="color:rgb(44, 62, 80);">cur当前节点 初始化为头结点</font>**

**<font style="color:rgb(44, 62, 80);">temp 临时节点 用于暂存cur的下一个节点 避免翻转的时候丢失链表的后续节点</font>**

**<font style="color:rgb(44, 62, 80);"></font>**

**<font style="color:rgb(44, 62, 80);">翻转过程</font>**

1. **<font style="color:rgb(44, 62, 80);">保存cur.next 到temp  </font>**
2. **<font style="color:rgb(44, 62, 80);">将cur.next设置为pre 翻转当前节点的指针</font>**
3. **<font style="color:rgb(44, 62, 80);">将pre更新为cur 前一个节点就是现在的节点</font>**
4. **<font style="color:rgb(44, 62, 80);">cur设置为temp 向链表的下一个节点移动</font>**
5. **<font style="color:rgb(44, 62, 80);">返回新头结点 pre指向原本链表的最后一个节点 这个节点也就是翻转过后的新头结点  
</font>**

```java
public Node reverseList(Node head){
    Node pre = null, cur = head, temp = null;
    while(cur != null){
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

<font style="color:rgb(44, 62, 80);">  
</font>

**写法二: 递归**



```java
public Node reverseList(Node head){
    return reverse(null, head);
}

private Node reverse(Node pre, Node cur){
    if(cur == null) return pre;
    Node temp = null;
    temp = cur.next;
    cur.next = pre;  // 翻转

    return reverse(cur, temp);
}
```



# day4
### lc19 删除倒数第k个节点
> 本题的关键在于怎么找到倒数第k个节点呢?
>
> **使用快慢指针, f快指针先移动k+1步,让f和s相差k个节点, 然后快慢同时走,直到快指针到尾巴,此时慢指针就是倒数第k个节点**
>



```java
public static Node removeNthFromEnd(Node head, int n) {
    // 1. 虚拟头结点 创建双指针
    Node temp = new Node(-1);
    temp.next = head;
    Node f = temp, s = temp;
    // 2. 快指针走k+1
    for(int i = 0; i <= n; i++) f = f.next;
    // 3. f s同时走
    while(f != null){
        f = f.next;
        s = s.next;
    }
    // 4. 删除s指向 的节点 并返回
    if(s.next != null) s.next = s.next.next;
    return temp.next

}

```



### 链表相交
**本题关键在于:**

> **设置双指针 当两个指针遍历完自己的链表之后，在切换到对方的链表继续遍历。只要相遇，那一定是在交点相遇。如果没有交点，那就在 **`**null**`** 相遇。  
**
>

```java
public Node getIntersectionNode(Node headA,Node headB){
    Node indexA = headA, indexB = headB;
    while(indexA != indexB){
        if(indexA == null) indexA = headB;
        else indexA = indexA.next;
        if(indexB == null) indexB = headA;
        else indexB = indexB.next;
    }
    return indexA;

}

```



### lc142. 环形链表II
本题包含两部分

1. **判断是否有环**

通过快慢指针 但凡相遇 那一定有环

2. **找到环的入口**

有环之后 定义两个指针 一个指向快或者慢指针  一个指向头结点 开始同步移动 当两个相等相遇的地方 一定是环的入口



```java
public Node detectCycle(Node head) {
    Node f = head, s = head;
    while(f != null && f.next != null){
        f = f.next.next;
        s = s.next;
        if(f == s){
            Node index1 = f, index2 = head;
            while(index1 != index2){
                index1 = index1.next;
                index2 = index2.next;
            }
            return index1;
        }
    }	

    return null;
}
```



### lc24 两两交换链表中的节点
本题依旧采用虚拟头结点方式

修改这个节点的指向 必须找到这个节点的前一个节点指针

改变指针的走向实现交换  并不是交换数值



1. 虚拟头结点



2.  定义 cur 变量并初始化为 dumpHead，用于遍历链表，控制节点交换。

定义辅助变量 :

`temp`: 临时节点，保存两个节点后面的节点

`firstNode`、保存两个节点之中的第一个节点

`secondNode`，保存两个节点之中的第二个节点



3. while循环 条件是是 `cur.next` 和 `cur.next.next` 不为 `null`

其中`cur.next` 和 `cur.next.next` 代表一对要交换的节点，如果不足一对（即只剩下一个节点或没有节点），则循环结束。



4. 交换

`temp` 保存第二个节点的下一个节点，

`firstNode` 指向当前要交换的第一个节点，`secondNode` 指向当前要交换的第二个节点。

开始交换.....

+ `cur.next = secondNode`：将 `cur` 的下一个节点指向 `secondNode`，完成第一步交换。
+ `secondNode.next = firstNode`：将 `secondNode` 的下一个节点指向 `firstNode`，完成第二步交换。
+ `firstNode.next = temp`：将 `firstNode` 的下一个节点指向 `temp`（即下一对的第一个节点）。
+ `cur = firstNode`：将 `cur` 移动到 `firstNode`，准备开始下一轮交换。

```java
public Node swapPairs(Node head) {
    Node dumpHead = new Node(-1);
    dumpHead.next = head;
    Node cur = dumpHead, temp, firstNode, secondNode;
    while(cur.next != null && cur.next.next != null){
        temp = cur.next.next.next;
        firstNode = cur.next;
        secondNode = cur.next.next;

        cur.next = secondNode;
        secondNode.next = firstNode
        firstNode.next = temp;
        cur = firstNode;

    }
    return dumpHead.next;
}
```





# day06哈希表


> <font style="color:rgb(44, 62, 80);">总结的来说，</font>**<font style="color:rgb(44, 62, 80);">当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</font>**<font style="color:rgb(44, 62, 80);">。</font>
>
> <font style="color:rgb(44, 62, 80);">但是哈希法也是</font>**<font style="color:rgb(44, 62, 80);">牺牲了空间换取了时间</font>**<font style="color:rgb(44, 62, 80);">，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</font>
>



### lc242<font style="color:#1a1a1a;">有效的字母异位词</font>
> <font style="color:rgb(44, 62, 80);">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</font>
>
> <font style="color:rgb(44, 62, 80);">示例 1: 输入: s = "anagram", t = "nagaram" 输出: true</font>
>
> <font style="color:rgb(44, 62, 80);">示例 2: 输入: s = "rat", t = "car" 输出: false</font>
>
> **<font style="color:rgb(44, 62, 80);">说明:</font>**<font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">你可以假设字符串只包含小写字母。</font>
>



读题可以看不懂到底什么是<font style="color:#1a1a1a;">字母异位词呢? </font>

大白话就是 给定两个字符串 判断是否有相同的字母组成(不管顺序)

比如 abbc  --- bbac 这这就是一对<font style="color:#1a1a1a;">字母异位词</font>



因为知道这些字母只能是小写字母  而且字母的asc码都是连续的

所以可以定一个数组 大小是26 刚好能放入26个字母 用来记录<font style="color:rgb(44, 62, 80);">字符串s里字符出现的次数。</font>

<font style="color:rgb(44, 62, 80);">因为asc码都是连续的 所以a到z是26个连续的数 所以将(s[i] - 'a')++ 求出来一个数字</font>

<font style="color:rgb(44, 62, 80);">同样,在便利t的时候,只需要-- 就可以了</font>

<font style="color:rgb(44, 62, 80);">其实也就是26个字母对应26个下标 出现一次就对应下标加一 出现的位置比如</font>

<font style="color:rgb(44, 62, 80);">t='abcdef.....z' 26个 那么依次加加操作之后就是 arr[1,1,1,1,1,1,1,1,1,1,1,1,......1]  26个1</font>

<font style="color:rgb(44, 62, 80);"></font>

<font style="color:rgb(44, 62, 80);">最后检查这个数组,如果有元素不等于0 说明s或者t字符串一定有一个多了 或者少了</font>

<font style="color:rgb(44, 62, 80);">如果都是等于0 说明就是</font><font style="color:#1a1a1a;">字母异位词</font>

<font style="color:rgb(44, 62, 80);">时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。</font>

<font style="color:#1a1a1a;">--------</font>

<font style="color:#1a1a1a;">也就是:</font>

<font style="color:#1a1a1a;">第一次便利s的时候 遇到每个字母就把他在数组对应的位置加1  表示出现过</font>

<font style="color:#1a1a1a;">第二次便利t的时候  遇到的时候 就把对应位置减1 </font>

<font style="color:#1a1a1a;">如果最后结果数组都是0  代表两个字符串完全相等  
</font>



```java
public boolean isAnagram(String s, String t) {
    int[] arr = new int[26];

    for(int i = 0; i < s.length(); i++) arr[s.charAt(i) - 'a']++;

    for(int i = 0; i < t.length(); i++) arr[t.chatAt(i) - 'a']--;

    for(int c : arr){
        if(c != 0) return false;
    }
    return true;
}

```

  


### lc349<font style="color:rgb(44, 62, 80);">两个数组的交集  
</font>
> <font style="color:rgb(44, 62, 80);">题意：给定两个数组，编写一个函数来计算它们的交集。</font>
>
> <font style="color:rgb(44, 62, 80);">输入：nums1 = ［4,9,5］，nums2 = ［9,4,9,8,4］</font>
>
> <font style="color:rgb(44, 62, 80);">输出：［9,4］</font>
>



使用set结构 定义 s1  res

s1 用于存放num1中的元素也就是  s1 = {4,9,5}

res 用于nums1和nums2经过去重之后交集部分

执行结果：

+ `nums2[0] = 9`，`s1` 包含 `9`，添加到 `res`：`res = {9}`
+ `nums2[1] = 4`，`s1` 包含 `4`，添加到 `res`：`res = {9, 4}`
+ `nums2[2] = 9`，`res` 已经包含 `9`，所以不重复添加。
+ `nums2[3] = 8`，`s1` 不包含 `8`，跳过。
+ `nums2[4] = 4`，`res` 已经包含 `4`，所以不重复添加。

最终，`res = {9, 4}`，这是 `nums1` 和 `nums2` 的交集。

```java
public int[] intersection(int[] nums1, int[] nums2) {
    if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) return new int[0];

    // 初始化set
    Set<Integer> s1 = new HashSet<>();
    Set<Integer> res = new HashSet<>();

    //便利num1
    for(int i : nums1) s1.add(i);

    // 便利num2时候需要先去重
    for(int i : nums2){
        if(s1.contains(i)) res.add(i);
    }

    //申请新数组存放结果 并且返回
    int[] arr = new int[res.size()];
    int index = 0;
    for(int num : res) arr[index++] = num;
    return arr;
}

```

### lc202 快乐数


> <font style="color:rgb(44, 62, 80);">「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</font>
>

<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">编写一个算法来判断一个数 </font>`<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">n</font>`<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 是不是快乐数。</font>

<font style="color:rgb(44, 62, 80);">题目中说了会 </font>**<font style="color:rgb(44, 62, 80);">无限循环</font>**<font style="color:rgb(44, 62, 80);">，那么也就是说</font>**<font style="color:rgb(44, 62, 80);">求和的过程中，sum会重复出现</font>**



<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"></font>

<font style="color:rgb(44, 62, 80);">这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</font>

<font style="color:rgb(44, 62, 80);"></font>

```java
public boolean isHappy(int n) {
    Set<Integer> set = new HashSet<>();
    while(n != 1 && set.contains(n)){
        set.add(n);
        n = getNumber(n);

    }
    return n == 1;

}
public int getNumber(int n) {
    int res = 0;
    while(n > 0){
        int temp = n % 10 //取出个位
        res += temp * temp;
        n /= 10; 

    }
    return res;
}


```

### lc1 两数之和
**梦的开始!!!!!**



使用map来记录数字和下标

<font style="color:rgb(44, 62, 80);"> map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。</font>



```java
public int[] twoSum(int[] nums. int target){
    int[] res = new int[2];
    if(nums == null || nums.length ==0) return res;

    Map<Integer, Integer> map = new HashMap<>();
    for(int i = 0; i < nums.length; i++){
        int temp = target - nums[i];
        if(map.containsKey(temp)){
            res[1] = i;
            res[0] = map.get(temp);
            break;

        }
        map.put(nums[i], i);

    }
    return res;


}
```

# day7
### lc383 救赎信
> <font style="color:#333333;">和 242.有效的字母异位词 是一个思路 ，算是拓展题 </font>
>

lc383是求字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a 

**通过题意得出 1. magazines里面元素不能重复使用     2. 只有小写**

****

```java
   public boolean canConstruct(String ransomNote, String magazine){
        if(ransomNote.length() > magazine.length()) return false;
        
        int[] res = new int[26];
        
        for(char c : magazine.toCharArray()) res[c - 'a']++;
        
        for(char c : ransomNote.toCharArray()) res[c - 'a']--;
        
        for(int i : res){
            if(i < 0) return false;
        }
        return true;
    }
```

### lc454 四数相加II


> 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，  请你计算有多少个元组 (i, j, k, l) 能满足： 
>
> 1. 0 <= i, j, k, l < n 
> 2. nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 
>



**给你4个数组 在这4个数组分别找出一个元素 使得这几个元素相加等于0  问你一共多少对符合条件的(不要求分别是多少 只要有多少个符合要求)**

****

因为是在4个数组里面 分别找一个 所以不用考虑去重

**解法一: 暴力**

暴力法: 4个for循环去便利4个数组 然后相加等于0的话 就++; 最后返回cout

但是时间复杂度是n的4次方



解法二: 使用HashMap  **不仅要统计元素 还要统计次数**

把4个数组分成两组,前两个数组 元素为a+b 放入map的key 同时统计a+b出现的次数

然后便利cd数组时候 去判断0-(c+d)有没有出现过 统计出现过的次数 然后count加value的值

****

**为什么分成两组?**

因为两个for循环时间复杂度是n的平方  另外一组的两个for也是n的平方 所以整体时间复杂度就是n的平方 因为时间复杂度是不管常数项的

****

**为什么是 0-(c+d)?**

如果0-(c+d) = a + b  ----> 那么就是 a+b+c+d = 0

****

```java
  public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        int res = 0;
        // 统计前两个数组中的元素之和并且统计次数
        // 如果sum存在map  返回 对应值(出现次数) 不在就默认返回0
        for(int i : nums1){
            for(int j : nums2){
                int sum = i + j;
                map.put(sum, map.getOrDefault(sum, 0) + 1);
            }
        }
        // 统计后俩
        for(int i : nums3){
            for (int j : nums4){
                res += map.getOrDefault(0 - i - j, 0);
            }
        }
        return res;
    }
```

** **

### lc15 三数之和


> **  ****<font style="color:rgb(44, 62, 80);">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</font>**
>

****

注意 : 一个数组里面     去重



**因为需要对ABC都要进行去重操作 所以属于双指针更加方便**

先进行排序 然后三个指针 i  l  r   i定于在数组开头   l在i+1位置  r在尾巴

也就转换成arr[i]+arr[l]+arr[r] = 0  接下来就是移动指针的操作了

如果三个相加大于0   那么l向后移动  直到l和r相遇

但是要对abc去重 也就是arr[i]  arr[l]  arr[r] 进行去重操作

如果a重复了  因为所以应该跳过去

**还有一个问题就是判断arr[i] 和 arr[i + 1] 还是判断 arr[i - 1] 和 arr[i]呢?**

如果是判断i+1进行去重的话 就把三元组结果集里面的重复数据去除了 比如{-1,-1,2} 

**<font style="color:rgb(44, 62, 80);">我们要做的是 不能有重复的三元组，但结果集内的元素是可以重复的！</font>**

```plain
if (i > 0 && nums[i] == nums[i - 1])  continue;
```

  
那么b和c怎么去重呢?

其实这个去重应该放在找到一个结果集之后再进行去重

```java
while (right > left && nums[right] == nums[right - 1]) right--;
while (right > left && nums[left] == nums[left + 1]) left++;
```

****

**整体代码**

```java
public List<List<Integer>> threeSum(int[] nums) {
    Arrays.sort(nums);
    List<List<Integer>> res = new ArrayList<>();

    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0) break; // 如果当前数大于0，则直接结束循环
        if (i > 0 && nums[i] == nums[i - 1]) continue; // 去重

        int l = i + 1, r = nums.length - 1; // 每次for循环都重新初始化l和r
        while (l < r) {
            int sum = nums[i] + nums[l] + nums[r];
            if (sum > 0) r--;
            else if (sum < 0) l++;
            else {
                res.add(Arrays.asList(nums[i], nums[l], nums[r]));

                // 去重处理
                while (l < r && nums[r] == nums[r - 1]) r--;
                while (l < r && nums[l] == nums[l + 1]) l++;
                r--;
                l++;
            }
        }
    }
    return res;
}
    
```



### lc18 四数之和  

> 思路和三数之和差不多 就是多套了一层for
>
> 三数之和是三个指针 那么四数就是4个指针  关键点是target可以是负数  两个负数相加是可以变得更小的 所以在去重的时候要加大于0的条件
>



<font style="color:rgb(44, 62, 80);">四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。</font>



```java
public List<List<Integer>> fourSum(int[] nums, int target) {
    // 排序数组
    Arrays.sort(nums);
    List<List<Integer>> res = new ArrayList<>();
    for(int k = 0; k < nums.length; k++){
        // 剪枝
        if(nums[k] > target && nums[k] > 0) break;
        //去重
        if(k > 0 && nums[k] == nums[k - 1]) continue;

        for(int i = k + 1; i < nums.length; i++){
            // 剪枝 去重i
            if(nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) break;
            if(i > k + 1 && nums[i] == nums[i - 1]) continue;
            // l 和 r
            int l = i + 1, r = nums.length - 1;
            while (l < r){
                long sum = nums[k] + nums[i] + nums[l] + nums[r];
                if(sum > target) r--;
                else if (sum < target) l++;
                else {
                    res.add(Arrays.asList(nums[k],nums[i],nums[l],nums[r]));
                    // l 和 r去重
                    while (l < r && nums[r] == nums[r - 1]) r--;
                    while (l < r && nums[l] == nums[l + 1]) l++;
                    r--;
                    l++;
                }
            }
        }

    }
    return res;
}
```



# day08--字符串篇章
### lc344 翻转字符串
> 本题使用双指针 一个卡在开头  一个卡在结尾 ,同时向中间移动  然后交换两个指针指向的数
>

其中交换数可以使用第三个变量temp 也可以使用位运算不借助任何其他

原理如下:

假设

int a = 13,b = 14

a = a ^ b;

b = a ^ b;

a = a ^ b;

------------

证明： 假设 a是甲，b是乙

a = 甲 ^ 乙

b = 甲 ^ 乙 ^ 乙 = 甲

a = 甲 ^ 乙 = 甲 ^ 乙 ^ 甲 = 乙

-----

注意： a,b两个数必须不同位置，不同地址



本题注意 如果要携程   
s[l] = s[l] ^ s[r]; 		s[r] = s[l] ^ s[r];		s[l] = s[l] ^ s[r];

需要进行类型转换 (char)

 s[l] = (char) (s[l] ^ s[r]); 	s[r] = (char) (s[l] ^ s[r]);	s[l] = (char) (s[l] ^ s[r]);

而使用^= 会自动进行类型转换  


```java
public void reverseString(char[] s) {
    int l = 0, r = s.length - 1;
    while(l < r){
        s[l] ^= s[r];
        s[r] ^= s[l];
        s[l] ^= s[r];
        l++;
        r--;
    }

}
```

解法二: 队列

因为队列是先进后出  入栈之后 再取出自动完成倒序了  但是缺点是消耗内存 

```java
public void reverseString(char[] s) {
    Stack<Character> stack = new Stack<>();
    
    // 将所有字符压入栈中
    for (char c : s) stack.push(c);
    
    // 将字符从栈中弹出，依次放回数组
    int i = 0;
    while (!stack.isEmpty()) s[i++] = stack.pop();
}


```

### lc541翻转字符串II
> 给定一个字符串 s 和一个整数 k，从字符串开头算起， 每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 
>
> 剩余字符少于 k 个，则将剩余字符全部反转。 
>
> 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 
>



题目意思是 假设字符串是"12345678"  k= 3   

其中2k也就是6  翻转前k也就是翻转1-3   剩余78 不够k 就全部翻转 

变成"32145687"

因为每次都是2k  所以for循环时候 直接i+=2k

 

```java
public String reverseStr(String s, int k) {
    char[] ch = s.toCharArray();
    // 1. 每隔2k翻转前k
    for(int i = 0; i < ch.length; i += 2 * k){
        // 2. 剩余 >=x并且<2k 那就翻转前k
        if(i + k <= ch.length){
            reverse(ch, i, i + k - 1);
            continue;
        }
        //3. 剩余的<k 那就把剩余的全部翻转
        reverse(ch, i, ch.length - 1);
    }
    return new String(ch);

}
public void reverse(char[] ch, int i, int j) {
    while (i < j){
        ch[i] ^= ch[j];
        ch[j] ^= ch[i];
        ch[i] ^= ch[j];
        i++;
        j--;
    }
}
```

### 替换数字
> <font style="color:rgb(44, 62, 80);">给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</font>
>
> <font style="color:rgb(44, 62, 80);">例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。</font>
>

第一步 肯定要先把数组扩容到能够容纳转换后的大小

比如原本<font style="color:rgb(44, 62, 80);"> "a5b" 的长度为3  那么转换后就是"anumberb" 长度为 8。</font>

<font style="color:rgb(44, 62, 80);">然后使用双指针 从后向前替换掉数字 i指针指向新长度的尾巴  j指向旧长度的尾巴</font>

<font style="color:rgb(44, 62, 80);">从旧数组 从后向前 开始赋值到新数组  新数组也是后向前便利将s[j]赋值给s[i]</font>

<font style="color:rgb(44, 62, 80);">因为从后往前就可以避免元素的移动</font>

<font style="color:rgb(44, 62, 80);">本题使用oj模式</font>

```java
// 先把原数组复制到扩展长度后的新数组，然后不再使用原数组、原地对新数组进行操作。
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        int len = s.length();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) >= 0 && s.charAt(i) <= '9') {
                len += 5;
            }
        }
        
        char[] ret = new char[len];
        for (int i = 0; i < s.length(); i++) {
            ret[i] = s.charAt(i);
        }
        for (int i = s.length() - 1, j = len - 1; i >= 0; i--) {
            if ('0' <= ret[i] && ret[i] <= '9') {
                ret[j--] = 'r';
                ret[j--] = 'e';
                ret[j--] = 'b';
                ret[j--] = 'm';
                ret[j--] = 'u';
                ret[j--] = 'n';
            } else {
                ret[j--] = ret[i];
            }
        }
        System.out.println(ret);
    }
}
```



# day9


### lc151 翻转字符串的单词
> <font style="color:rgb(44, 62, 80);">给定一个字符串，逐个翻转字符串中的每个单词。</font>  
<font style="color:rgb(44, 62, 80);">示例 1：</font>  
<font style="color:rgb(44, 62, 80);">输入: "the sky is blue"</font>  
<font style="color:rgb(44, 62, 80);">输出: "blue is sky the"</font>
>
> <font style="color:rgb(44, 62, 80);">注意: 1. 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</font>
>
> 2. <font style="color:rgb(44, 62, 80);">如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</font>
>

<font style="color:rgb(44, 62, 80);">从题目提取的信息: 1.  依照单词为单位进行翻转(字母顺序不能变)   </font>

2. <font style="color:rgb(44, 62, 80);">结果的前后不能有空格</font>
3. <font style="color:rgb(44, 62, 80);">单词之间如果有多个空格 只保留一个</font>

<font style="color:rgb(44, 62, 80);"></font>

<font style="color:rgb(44, 62, 80);">翻转思路:  "the sky is blue"</font>

1. 先不管字母顺序 整体进行翻转 保证单词的位置一致---变成 "eulb si yks eht"
2. 再翻转单词 确保单词顺序 "blue is sky the"



所以整体思路就是

1. 移除多余的空格
2. 先全部翻转句子
3. 翻转单词



```java
class Solution {
    public String reverseWords(String s) {
        char[] chars = s.toCharArray(); // 先转成字符数组
        chars = delSpaces(chars);   // 1. 处理空格
        reverse(chars, 0, chars.length - 1);  // 2.翻转句子
        reverseEasyWord(chars);  // 3. 翻转单词
        return new String(chars);
    }
    public char[] delSpaces(char[] c){
        int s = 0;
        for(int f = 0; f < c.length; f++){
            if(c[f] != ' ') {
                if(s != 0) c[s++] = ' ';
                while(f < c.length && c[f] != ' ') c[s++] = c[f++];
            }
        }
        char[] newChar = new char[s];
        System.arraycopy(c, 0, newChar, 0, s);
        return newChar;
    }
    public void reverse(char[] c, int l , int r){
        if(c.length <= r) return;
        while(l < r){
            c[l] ^= c[r];
            c[r] ^= c[l];
            c[l] ^= c[r];
            l++;
            r--;
        }
    }
    public void reverseEasyWord(char[] c){
        int start = 0;
        for(int end = 0; end <= c.length; end++){
            if(end == c.length || c[end] == ' '){
                reverse(c, start, end - 1);
                start = end + 1;
            }
        }
    }

}
```



### 右旋字符串 
> <font style="color:rgb(44, 62, 80);">字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</font>
>
> <font style="color:rgb(44, 62, 80);">对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。</font>
>

<font style="color:rgb(44, 62, 80);">思路:</font>

<font style="color:rgb(44, 62, 80);"> 把字符串分成两部分 第一段是字符串的长度-n    第二段长度是n  也就是转换成 把第二段放在开头 把第一段放在后面</font>

<font style="color:rgb(44, 62, 80);">先不考虑整体顺序  把整体进行翻转  然后再来一次翻转</font>

```java
import java.util.*;

public class Main{
    
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = Integer.parseInt(sc.nextLine());
        
        String s = sc.nextLine();
    
        int len = s.length();
        char[] c = s.toCharArray();
        // 翻转整体
        reverString(c, 0, len - 1)
        // 原本的第二段变成了第一段 所以开始是0  结束是n-1
        reverString(c, 0, n - 1);
        // 翻转原本的第一段
        reverString(c, n, len - 1);
        System.out.println(c);
        
        
    }
    public static void reverString(char[] ch, int l ,int r){
        while (l < r){
            ch[l] ^= ch[r];
            ch[r] ^= ch[l];
            ch[l] ^= ch[r];
            l++;
            r--;
        } 
    }
}
```

### KMP算法基础
#### 理论基础
> <font style="color:rgb(44, 62, 80);"></font>**<font style="color:rgb(44, 62, 80);">当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</font>**
>

**假设 文本串是"aabaabaaf"  目标是"aabaaf"  求文本串是否出现了目标串**

字符串1	aabaabaaf

字符串2	aabaaf

 kmp算法就是字符串2 在f不匹配的位置   他会跳到b也就是之前匹配过的内容



那么如何找到b呢  就是使用**前缀表    **找到不匹配f的前面是aa 那么就找到aa相等的前缀的后面 重新开始匹配

什么是前缀什么是后缀?  aabaaf

前缀是包含首字母 不包含尾巴的所有子串 也就是 a	aa	aab	aaba	aabaa

后缀是包含尾巴 不包含开头的所有子串 f	af	aaf	baaf	abaaf

**最长相等前后缀**

a		因为即是开头又是结尾  所以是没有前后缀

aa		前缀a  后缀a  所以1

aab   	因为开头a结尾b  所以找不到相等 是0

aaba	 	前缀是aab   后缀aba  相等的是a 所以长度是1

aabaa        前缀aaba   后缀是abaa  相同是aa 长度为2

aabaaf	 前缀aabaa  后缀是abaaf  因为f在前缀中不存在 所以是0

**所以aabaaf的前缀表就是[0 1 0 1 2 0]   那么是怎么匹配的呢**

文本串	a	a	b	a	a	b	a	a	f

模式串	a	a	b	a	a	f

前缀表 	0	1	0	1	2	0

 

遇到f不匹配了 找前面最长相等前后缀 也就是2 也就意味着 有个后缀aa  前面也有个相同的aa

然后跳到前面相等的前缀后面  也就是aa的后面 就是b     

------------------

在kmp算法中都会提到next数组

是遇到冲突的地方之后next数组会告诉我们回退到哪里  

会把前缀表做个右移的操作 或者统一减一的操作   

#### 代码实现
> 在代码实现中分为下面步骤
>
> 1. 初始化 next数组 各个变量	2. 处理前后缀不相同的情况	3. 相同的情况	4. 更新next
>

 这个2也就意味着需要跳到下标为2的元素上继续匹

1. **初始化**

j是指向前缀末尾位置 初始化为0 

i是指向后缀末尾位置   在for里面1开始

2. **前后缀不相同情况**

也就s[i] != s[j] 但是要保证j >0   j向前回退  看前一位的前缀表对应下标 j = next[j - 1]

3. **前后缀相同的情况**

也就是 if(s[i] == s[j])   j++;

3. **更新next**

next[i] = j



-------------------------

# day10--栈and队列
> 栈:  先进后出 		像弹夹 子弹压堂
>
> 队列: 先进先出		像管道 双端都有口
>



### Lc232 用栈实现队列
> <font style="color:rgb(44, 62, 80);">使用栈实现队列的下列操作</font>
>
> <font style="color:rgb(44, 62, 80);">push(x) -- 将一个元素放入队列的尾部。  
</font><font style="color:rgb(44, 62, 80);">pop() -- 从队列首部移除元素。  
</font><font style="color:rgb(44, 62, 80);">peek() -- 返回队列首部的元素。  
</font><font style="color:rgb(44, 62, 80);">empty() -- 返回队列是否为空。</font>
>



```java
public class Lc232_myQueue {
    Stack<Integer> sIn, sOut;

    public Lc232_myQueue() {
        sIn = new Stack<>();  //进栈
        sOut = new Stack<>(); //出栈

    }

    public void push(int x) {
        sIn.push(x);
    }
    public int pop() {
        dumpStackIn();
        return sOut.pop();

    }

    public int peek() {
        dumpStackIn();
        return sOut.peek();

    }

    public boolean empty() {
        return sIn.isEmpty() && sOut.isEmpty();
    }
//    如果出栈为空 那么就将In中的元素全部放入Out里面
    private void dumpStackIn() {
        if(!sOut.isEmpty()) return;
        while (!sIn.isEmpty()) sOut.push(sIn.pop());
    }
}
```

### Lc<font style="color:rgb(44, 62, 80);">225. 用队列实现栈</font>
> <font style="color:rgb(44, 62, 80);">使用队列实现栈的下列操作：</font>
>
> + <font style="color:rgb(44, 62, 80);">push(x) -- 元素 x 入栈</font>
> + <font style="color:rgb(44, 62, 80);">pop() -- 移除栈顶元素</font>
> + <font style="color:rgb(44, 62, 80);">top() -- 获取栈顶元素</font>
> + <font style="color:rgb(44, 62, 80);">empty() -- 返回栈是否为空</font>
>

**一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。**



```java

class Lc225_myStack {
    Queue<Integer> q;

    public Lc225_myStack() {
        q = new ArrayDeque<>();
    }

    public void push(int x) {
        q.add(x);
    }

    public int pop() {
        rePosistion();
        return q.poll();

    }
    public int top() {
        rePosistion();
        int res = q.poll();
        q.add(res);
        return res;
    }

    public boolean empty() {
        return q.isEmpty();
    }
    private void rePosistion() {
        int size = q.size();
        size--;
        //只要 size 仍然大于 0，就继续循环，同时在每次循环中 size 会减 1。
        while (size-- > 0) q.add(q.poll());
    }

}

```



### Lc20有效的括号
> ### 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 

其实总的来说不匹配的情况一共有三种

1. **左边( 多余**

在便利字符串的时候 遇到了左的({[  就把对应的右括号放入栈内

如果便利的时候遇到了右边的 就弹出对应栈内的括号 

如果字符串遍历完了 但是栈不为空 说明 不匹配  多了



2. **(}  类型不匹配**

遇到相同方向的  但是对比发现类型不一样 

3. **右边多了**

字符串还没遍历完  栈就空了



```java
public boolean isValid(String s) {
    // 如果长度是奇数 那一定不满足要求
    if(s.length() % 2 != 0) return false;

    Deque<Character> deque = new LinkedList<>();
    char ch;
    for(int i = 0; i < s.length(); i++){
        ch = s.charAt(i);
        if(ch == '(') deque.push(')');
        else if (ch == '{') deque.push('}');
        else if(ch == '[') deque.push(']');
        // 情况23
        else if (deque.isEmpty() || deque.peek() != ch) return false;
        else deque.pop();
    }
    // 情况1 字符串便利完了 但是栈不为空
    return deque.isEmpty();


}
```



### Lc1047. 删除字符串中的所有相邻重复项 
> 本题和上题的匹配括号类似, <font style="color:rgb(44, 62, 80);">本题是匹配相邻元素，最后都是做消除的操作</font>
>
> <font style="color:rgb(44, 62, 80);">那么栈的目的，就是存放遍历过的元素，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素。 然后再去做对应的消除操作</font>
>

<font style="color:rgb(44, 62, 80);"></font>

```java
class Solution {
    public String removeDuplicates(String s) {
        ArrayDeque<Character> q = new ArrayDeque<>();
        char ch;
        for(int i = 0; i < s.length(); i++){
            ch = s.charAt(i);
            if(q.isEmpty() || q.peek() != ch) q.push(ch);
            else q.pop();
        }
        String res = "";
        while(!q.isEmpty()) res = q.pop() + res;
        return res;
        
    }
}
```





# day11
### Lc150. <font style="color:rgb(44, 62, 80);">逆波兰表达式求值</font>
逆波兰表达式其实就是后缀表达式 <font style="color:rgb(44, 62, 80);">是指运算符写在后面。</font>  使用栈来求解

**遇到数字就放入栈内   遇到操作符就****<font style="color:rgb(44, 62, 80);">取出栈顶两个数字进行计算，并将结果压入栈中</font>**

**<font style="color:rgb(44, 62, 80);">注意: </font>**

**<font style="color:rgb(44, 62, 80);">在本题要注意:  减法和除法 是对前后两个顺序有要求 后弹出的减去  或者除以先弹出的.  因为在栈中，后进先出会导致先压入的元素在减法时应该作为减数，后压入的元素应作为被减数。  所以 减法的写法是 -d.pop() + d.pop()  如果不想这样写  就换成除法一样 两个int </font>**

```java
public int evalRPN(String[] tokens) {
    Deque<Integer> d = new LinkedList<>();
    for(String s : tokens){
        if("+".equals(s)) d.push(d.pop() + d.pop());
            
        else if("-".equals(s)) d.push(-d.pop() + d.pop());
            
        else if("*".equals(s)) d.push(d.pop() * d.pop());
        else if("/".equals(s)) {
            int n1 = d.pop();
            int n2 = d.pop();
            d.push(n2 / n1);
        }else d.push(Integer.valueOf(s));

    }
    return d.pop();


}
```



### LC239.滑动窗口最大值


> 使用单调队列  也就是维护队列里面单调递增或者递减
>







# day12-二叉树
### 基础概念
**树:**

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731289339324-8973d61e-0586-41d8-b4ed-b716de5530a3.png)

+ **树的度**：树内各个节点的最大值， 比如节点a 有3个节点，那度就是3
+ **叶子节点(终端节点)**：他的度为0，比如i j
+ **孩子、双亲： **比如a节点，他有3个子树t1,t2,t3  那这三个子树的根节点是bcd，那a节点的孩子就是bcd。bcd的双亲就是a
+ **兄弟节点： 如果节点有共同的双亲，那他们就是兄弟节点，比如hij的双亲都是d，那hij是兄弟节点**
+ **树的层： 横着来 有多少层**
+ **堂兄弟： 他们的双亲位于同一层**
+ **节点的祖先： 从根到该节点所经过分支上的所有节点，比如a到m需要经过a_d_h。那adh都是m的祖先**
+ **节点的子孙：以某节点为跟的子树中的任意节点都是该节点的子孙**
+ **树的深度（高度）： 树中节点的最大层次 **

---



**满二叉树: **

 如果一颗二叉树只有度为0的节点和 度为2的节点  并且度为0的节点在同一层上, 就是满二叉树

<font style="color:rgb(44, 62, 80);">这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731287330251-79cbedc7-9fff-4104-a5ad-19d1e164ce11.png)

**完全二叉树::**

除了最底层节点可能没有填满之外,其余的每一层的节点都达到了最大值,并且最下面一层的节点都几种在该层的最左边的若干位置, 如果最底层是h层  那么该层包含1~2^(h-1)个节点

---

大白话就是 左边节点/全是满的 不能缺  一旦缺少左边节点就不是了

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731287623967-976c0fe3-95d0-4570-be15-e085ecb9fbb7.png)



**平衡二叉树::(AVL)**

一颗空树 或者他的左右两个子树的高度差的绝对值不能超过1  并且左右两个子树都是AVL

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731287963580-a014e43d-a409-4fcd-8add-de4a51a9d6af.png)

<font style="color:rgb(44, 62, 80);">最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</font>

---

**二叉树的存储方式**

<font style="color:rgb(44, 62, 80);">链式存储(指针):通过指针把分布在各个地址的节点串联一起。</font>

**<font style="color:rgb(44, 62, 80);"></font>**

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731288675906-e23cf5ac-0eb5-4af6-8b27-441a0f18dd05.png)



<font style="color:rgb(44, 62, 80);">顺序存储(数组):</font>

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731288764057-cf2fdea3-ae33-430b-a20d-fae112216787.png)

**<font style="color:rgb(44, 62, 80);">如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 但一般常用链式存储</font>**

---

**二叉树的遍历**

****

**一. 深度优先遍历(看头在哪 也就是中间节点)**

1. 先序遍历:  头 -> 左 -> 右
2. 中序遍历:  左 -> 头 -> 右
3. 后序遍历:  左 -> 右 -> 头

**二. 广度优先遍历**

也就是层次遍历, 使用队列先进先出的特点 因为先进先出所以才能一层一层的便利

---

**Java中二叉树定义**

```java
public class Node{
    int v;
    Node l;
    Node r;
    Node(){
        
    }
    Node(int v){
        this.v = v;
    }
    Node(int v, Node l, Node r){
        this.v = v;
        this.l = l;
        this.r = r;
    }
    
}
```



### 二叉树遍历代码(递归)
节点的定义 如上, 下面代码不再定义节点

```java
// 调用递归方法
public List<Integer> preorderTraversal(Node root) {
    List<Integer> res = new ArrayList<>();
    prePrint(root, res);
    // midPrint(root, res);
    // postPrint(root, res);

    return res;
}
// lc144---前序便利 跟左右
public void prePrint(Node root, List<Integer> res) {
    if(root == null) return;
    res.add(root.v);
    prePrint(root.l, res);
    prePrint(root.r, res);
}
// lc94----中序遍历  左跟右
public void midPrint(Node root, List<Integer> res) {
    if(root == null) return;
    midPrint(root.l, res);
    res.add(root.v);
    midPrint(root.r, res);
}
// lc145---- 后续便利  左右跟
public void postPrint(Node root, List<Integer> res) {
    if(root == null) return;
    postPrint(root.l, res);
    postPrint(root.r, res);
    res.add(root.v);
}
```

朋友们,有没有发现一个规律呢?  

**就是主要看add行为在哪里  add在前面就是根左右--前序  中间就是左跟右--中序  最后就是左右跟-后续**

**为什么能由一个递归函数来实现呢?  递归序**



### 二叉树便利(迭代法)
> 使用栈, 压栈,  因为栈是先进后出  注意进出的顺序
>



**使用栈前序便利**

思路:

1. 创建个Stack栈 并且放入头结点
2. while便利 不为空时候    立马pop出头
3. 先压入右 再压入左   

```java
// lc144---前序便利 跟左右
public  List<Integer> prePrint(Node root) {
    List<Integer> res = new ArrayList<>();
    if(root == null) return res;
    Stack<Node> s = new Stack<>();
    s.push(root);
    while(!s.isEmpty()){
        root = s.pop();
        res.add(root.v);
        if(root.r != null) s.push(root.r);
        if(root.l != null) s.push(root.l);
    }
        
    return res;
   
}
```

**后遍历**

> **在前序便利是跟左右 入栈是先右再左. 那么后序遍历左右跟 改成	入栈 是跟右左  然后再把数组做一个翻转 就变成了左右跟 **
>
> **只需要在前序的基础上 入栈顺序改成先左再右  然后再使用库函数做一个翻转**
>

****

```java
public  List<Integer> postPrint(Node root) {
    List<Integer> res = new ArrayList<>();
    if(root == null) return res;
    Stack<Node> s = new Stack<>();
    s.push(root);
    while(!s.isEmpty()){
        root = s.pop();
        res.add(root.v);
        if(root.l != null) s.push(root.l);
        if(root.r != null) s.push(root.r);

    }
    Collections.reverse(res);
    return res;


}
```

**中序遍历**

****

> **中序遍历是 左跟右   在入栈时候关键在于先一直将左子节点压入栈，直到到达左子树的尽头，然后开始出栈访问节点，最后处理右子节点。**
>

```java
public List<Integer> midPrint(Node root){
    List<Integer> res = new ArrayList<>();
    if(root == null) return res;
    Stack<Node> s = new Stack<>();
    Node cur = root;
    while (cur != null && !s.isEmpty()){
        // 1. 遍历左子节点，将当前节点压入栈，并将 cur 移动到左子节点
        if(cur != null){
            s.push(cur);
            cur = cur.l;
        }else {
            // 2. 如果当前节点为空（说明已经到达左子树的尽头）
            // 从栈中弹出节点，访问该节点并将其值加入结果列表
            cur = s.pop();
            res.add(cur.v);
            // 3. 然后将 cur 移动到右子节点，继续对右子树进行相同操作
            cur = cur.r;
        }
    }
    return res;
}
```

### 二叉树前中后统一模版


在上面中序遍历中, 提到使用栈**<font style="color:rgb(44, 62, 80);">无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</font>**<font style="color:rgb(44, 62, 80);">。   </font>**<font style="color:rgb(44, 62, 80);">那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</font>**

<font style="color:rgb(44, 62, 80);">，</font>**<font style="color:rgb(44, 62, 80);">就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</font>**<font style="color:rgb(44, 62, 80);"> </font><font style="color:rgb(44, 62, 80);">这种方法也可以叫做标记法。</font>



```java
//      先序遍历
public List<Integer> prePrint(Node root) {
    List<Integer> res = new ArrayList<>();
    Stack<Node> s = new Stack<>();
    if (root != null) s.push(root);
    while (!s.isEmpty()){
        Node cur = s.peek();
        if(cur != null){
            s.pop();
            if(cur.r != null) s.push(cur.r);
            if(cur.l != null) s.push(cur.l);
            s.push(cur);
            s.push(null);
        }else{
            s.pop();
            cur = s.peek();
            s.pop();
            res.add(cur.v);
        }
    }
    return res;
}

// 后
public List<Integer> postPrint(Node root){
    List<Integer> res = new ArrayList<>();
    Stack<Node> s = new Stack<>();
    if(root != null) s.push(root);
    while (!s.isEmpty()){
        Node cur = s.peek();
        if(cur != null){
            s.pop();
            s.push(cur);
            s.push(null);
            if(cur.l != null) s.push(cur.l);
            if(cur.r != null) s.push(cur.r);
        }else{
            s.pop();
            cur = s.peek();
            s.pop();
            res.add(cur.v);
        }
    }
    return res;
}

/**
 * 中序遍历
 * @param root
 * @return
 */
public List<Integer> midPrint(Node root){
    List<Integer> res = new ArrayList<>();
    Stack<Node> s = new Stack<>();
    if (root != null) s.push(root);
    while (!s.isEmpty()){
        Node cur = s.peek();
        if(cur != null){
            s.pop();
            if(cur.r != null) s.push(cur.r);
            s.push(cur);
            s.push(null);
            if (cur.l != null) s.push(cur.l);
        }else {
            s.pop();
            cur = s.peek();
            s.pop();
            res.add(cur.v);
        }
    }

    return res;
}
```

仔细观察  重点在if(cur != null)上面  else等于空的情况是一样的  所以可以抽象出一个模版框架

```java
public List<Integer> xxxPrint(Node root){
    List<Integer> res = new ArrayList<>();
    Stack<Node> s = new Stack<>();
    if(root != null) s.push(root);
    while(!s.isEmpty()){
        Node cur = s.peek();
        if(cur != null){
            s.pop();
            // ....
            // ....
            // ....
            // ....
            

        }else{
            s.pop();
            cur = s.peek();
            s.pop();
            res.add(cur.v);
        }

    }
    return res;

}
```

那么代码里面的不等于空的时候怎么写呢?

通过调整**节点入栈顺序**和`null`标记的位置，可以实现不同的遍历顺序：

+ **前序遍历**：右r - 左l - 根 + `null`

因为前序便利是跟左右  那么入栈就是 右左跟 再来push一个null



if(cur.r != null) s.push(cue.r);

if(cur.l != null) s.push(cue.l);

s.push(cur);

s.push(null);

+ **中序遍历**：右 - 根 + `null` - 左

中序遍历是左跟右   入栈就是右 跟 null  左



if(cur.r != null) s.push(cue.r);

s.push(cur);

s.push(null);

if(cur.l != null) s.push(cur.l);



+ **后序遍历**：根 + `null` - 右 - 左

后续便利是左右跟  入栈是 跟  null   右  左

s.push(cur);

s.push(null);

if(cur.r != null) s.push(cue.r);

if(cur.r != null) s.push(cue.r);



# day14
### lc226.翻转二叉树


> 本题一定要理清遍历顺序,  翻转二叉树也就是 两两交换左右孩子 这个交换是指交换指针指向 并不是交换数字  
>
> 本题可以使用递归和非递归 但 优先掌握递归解法  使用前序和后续解
>

**既然是写递归 那必须明白递归三部曲**

1. **递归函数的返回值和参数**

返回翻转之后的根节点    <font style="color:rgb(44, 62, 80);">参数就是要传入节点的指针</font>

2. **终止条件**

if(root == null) return root;

3. **处理逻辑**

先处理前序便利 跟--- 左----右

在根节点的处理逻辑就是 进行交换左右

左  右  就是正常便利

sweap();

root.l;

root.r;

**这个是前序便利  但是把sweap交换函数放在下面呢?**

root.l;

root.r;

sweap();

**这种便利就是左右跟  也就是后续便利**

**但是能放在中间变成中序吗   不可的  **

因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）

---

```java
public TreeNode invertTree(Node root) {
    if(root == null) return root;
    sweap(root);
    invertTree(root.l);
    invertTree(root.r);
    return root;
}
public void sweap(Node root){
    Node temp = root.l;
    root.l = root.r;
    root.r = temp;
}

```

### lc101对称二叉树
![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731397756702-c61bec83-372c-4e48-b0e0-89ab2bb67428.png)



> 本质上对称二叉树也就是判断根节点的左子树和右子树是否可以相互翻转 
>
> 比较的话 是比较/\这种 外侧的节点是否相等 同时还有比较内侧节点是否相等 左的左 比较 右边的右
>
> 但是 便利顺序如何确定呢?
>

**lc101对称二叉树这道题  只能采用后续便利  左 ---- 右 ---- 跟**

因为要不断的收集左右孩子的信息返回给上一个节点 然后再左右 返回给上面  

如果是前序 跟左右 这种便利一上来就处理根节点  那么怎么找到左右孩子是否相互翻转呢 所以不能



按照递归三部曲

1. **确定递归函数  参数  返回值  **

返回值是布尔类型  参数要传入左右孩子

2. **终止条件**

情况一: 左边是空或者不为空  右边不是空或者是空  说明节点个数都不对 肯定不相同

情况二: 左右都空了 但是值不相同  说明个数对上了 但是值不一样 也是false

3. **处理逻辑**

外侧比较: 左节点的左孩子 比较右节点的右孩子 

外侧: 左节点的右孩子  比较 右节点的左孩子

如果内侧和外侧 都是true的情况 



```java
public boolean isSymmetric(Node root) {
    return compare(root.l, root.r);

}
public boolean compare(Node l, Node r) {
    if(l != null && r == null) return false;
    if(l == null && r != null) return false;
    if(l == null && r == null) return true;
    if(l.v != r.v) return false;

    boolean out = compare(l.l, r.r);
    boolean in = compare(l.r, r.l);
    return out && in;

}
```



### lc104_二叉树最大深度
> <font style="color:rgb(44, 62, 80);">给定一个二叉树，找出其最大深度。</font>
>

深度: 二叉树任意一个节点到根节点的距离 (取决于深度是0开始还是1开始)

高度: 任意一个节点 到叶子节点的距离 (看高度0开始还是1开始)

**确定便利顺序**

求高度 用后续  求深度 用前序便利   而根节点的高度就是二叉树的最大深度 最大深度 肯定是根节点开始

所以本题使用后续便利求二叉树最大深度  后续: 左---右----跟

递归三部曲

 返回值int   参数跟节点    便利的节点遇到空了就终止     

逻辑 按照后续便利 求左节点高度  有节点高度   在根节点 取左右的最大值  最后返回这个最大值再加一

```java
public int maxDepth(Node root){

    if(root == null) return 0;
    int lDepth = maxDepth(root.l);
    int rDepth = maxDepth(root.r);
    return Math.max(lDepth, rDepth) + 1;
}
```

**本题也可以使用一行代码搞定  但是那种并不利于新手理解 也看不出来是使用的后续便利 **

****

### lc111二叉树的最小深度
> <font style="color:rgb(44, 62, 80);">给定一个二叉树，找出其最小深度。</font>
>

**本题的最小深度是: 根节点到 最近的叶子节点**

****

**本题的坑在于  如果左子树 或者右子树 有一个是空的话  那么就要算非空子树的最小深度**

****

```java
public int minDepth(Node root){

    if(root == null) return 0;

    int lDepth = minDepth(root.l);
    int rDepth = minDepth(root.r);

    if(root.l == null) return rDepth + 1;
    if(root.r == null) return rDepth + 1;

    return Math,min(l, r) + 1;


}
```



# day15
### Lc110. 平衡二叉树
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定一个二叉树，判断它是否为平衡二叉树</font>
>

**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">平衡二叉树就是 任何一个节点 他的左右子树的高度相差不超过一   小于等于一</font>**

求高度 一定要使用后续便利  左--- 右---- 跟



```java
public boolean isBalanced(Node root){
    return getH(root) != -1;

}
public int getH(Node root){
    if(root == null) return 0;

    int lH = getH(root.l);
    if(lH == -1) return -1;

    int rH = getH(root.r);
    if(rH == -1) return -1;

    if(Math.abs(lH - rH) > 1) return -1;

    return Math.max(lH, rH) + 1;

}
```

### Lc257. 二叉树的所有路径
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个二叉树的根节点</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>`<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">root</font>`<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，按</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">任意顺序</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，返回所有从根节点到叶子节点的路径。</font>
>
> **<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">叶子节点</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">是指没有子节点的节点。</font>
>

**求路径 使用前序便利  跟--- 左--- 右   因为只有前序 才能让父节点指向他的孩子**

本题还会涉及到回溯  比如一个路径是 1 3 5    那么把本次路径弹出   回退到根节点  装下一条路径  回溯说白了其实就是把放入的元素给移除掉取出来

**递归三部曲**

1. **递归的参数**

根节点	每一条的路径	存放结果的结果集	  不需要返回值

2. **终止条件**

当找到叶子节点  也就是cur不等于空 但cur的左右孩子是空的情况下 就找到了叶子节点   找到叶子就是终止条件

3. **处理逻辑**

使用前序便利 先处理根节点  跟节点就是我们要记录路径上的节点 先放入path路径里面 

开始递归以及回溯   回溯是和递归异一一对应 有一个递归就有一个回溯  所以回溯应该放在递归的下一行 但在同级括号内

```java
public List<String> binaryTreePaths(Node root) {
    List<String> res = new ArrayList<>(); //结果
    List<Integer> path = new ArrayList<>(); //路径

    if(root == null) return res;

    getPath(root, path, res);
    return res;


}
public static void getPath(Node root, List<Integer> path, List<String> res) {
    //跟
    path.add(root.v);
    if(root.l == null && root.r == null){ // 遇到叶子节点
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < path.size() - 1; i++) sb.append(path.get(i)).append("->");

        sb.append(path.get(path.size() - 1));
        res.add(sb.toString());
        return;

    }
    //左
    if(root.l != null){
        getPath(root.l, path, res);
        path.remove(path.size() - 1); //回溯
    }
    //右
    if(root.r != null){
        getPath(root.r, path, res);
        path.remove(path.size() - 1);

    }

}

```

### lc404.左叶子之和
> <font style="color:rgb(44, 62, 80);">计算给定二叉树的所有左叶子之和。</font>
>

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731909662240-b8155568-69a1-4b01-a743-a6da28c47f58.png)

左叶子是什么:  

1. 首先也是叶子节点
2. 一定是父节点的左孩子

本题采用后续便利  左右跟  因为需要收集信息返回给根节点处理

如果便利到叶子节点 也就是左右孩子都是空  返回0  因为左子树 没有左叶子之和  右子树也没有右和



<font style="color:rgb(44, 62, 80);">如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶</font>

<font style="color:rgb(44, 62, 80);"></font>

<font style="color:rgb(44, 62, 80);">当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</font>

```java
public int sumOfLeftLeaves(Node root) {

    if(root == null) return 0;
    // 左  右 跟
    int lV = sumOfLeftLeaves(root.l);
    int rV = sumOfLeftLeaves(root.r);

    int mid = 0;
    if(root.l != null && root.l.l == null && root.l.r == null) mid = root.l.v;
    return mid + lV + rV;
}
```

<font style="color:rgb(44, 62, 80);">  
</font>

### lc222. 完全二叉树的节点个数
> <font style="color:rgb(44, 62, 80);">给出一个完全二叉树，求出该树的节点个数。</font>
>

什么是完全二叉树呢?

除了底层节点  上面的节点全部是满的  底层节点是左到右 ** 左节点必须存在  否则不是完全二叉树**

```java
public int countNodes(Node root){

    if(root == null) return 0;

    return countNodes(root.l) + countNodes(root.r) + 1;

}
```

# day16
### lc513. 找树左下角的值


> <font style="color:rgb(44, 62, 80);">给定一个二叉树，在树的最后一行找到最左边的值。</font>
>

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731916560101-dc3eb8d1-0e32-4f07-a5c7-c5cdf11cf6c8.png)

树的最后一行   的 最左值

**怎么找左下角呢?**

只需要求深度最大的叶子节点  那么一定是最后一行   找到最后一行之后 使用前序便利 只要能保证左边优先进行搜索就行  然后记录最大的叶子节点  此时就是树的最后以后最左位置



递归法

```java
class Solution {
    int Deep = -1, value = 0;
    public int findBottomLeftValue(TreeNode root) {
        value = root.val;
        findLeft(root ,0);
        return value;
        
    }
    public void findLeft(TreeNode root, int d){
        if(root == null) return;
        if(root.left == null && root.right == null){
            if(d > Deep){
                value = root.val;
                Deep = d;
            }
        }
        if(root.left != null) findLeft(root.left, d + 1);
        if(root.right != null) findLeft(root.right, d + 1);
    }
}
```



迭代法

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        int res = 0;
        while(!q.isEmpty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode poll = q.poll();
                if(i == 0) res = poll.val;
                if(poll.left != null) q.offer(poll.left);
                if(poll.right != null) q.offer(poll.right);
            }
        }
        
      return res;

    }
}
```

### lc112.路径总和
> <font style="color:rgb(44, 62, 80);">给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</font>
>
> <font style="color:rgb(44, 62, 80);">说明: 叶子节点是指没有子节点的节点。</font>
>

<font style="color:rgb(44, 62, 80);"> 给定如下二叉树，以及目标和 sum = 22</font>

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1731919347895-28338ebd-bda0-4057-a322-b075b86fea11.png)

**注意:  是根节点到叶子结点的路径   只要有一条符合  那就是true**

**只要看到二叉树  就要想便利顺序  本题任何顺序都可以  因为不涉及根节点的处理逻辑  根节点放在哪里都可以**

---

递归三部曲

1. **确定返回值和参数 **

返回boolean类型  只要有符合的就返回  参数是跟节点root , 计数器int count ,这里**直接传入目标值,  遇到一个节点就把节点数值做减法操作,  如果到叶子节点 count等于0了 说明符合**

2. **终止条件**

如果跟是null  那直接返回false

遇到叶子节点 判断   左右孩子都是空 并且count等于0  就终止 return true

如果遇到叶子了  但是count不等于0  那说明不是符合的路径 return false;

3. **单层递归的逻辑**

向左便利  把目标值做减法  然后左递归   

本题递归函数返回类型是Boolean   如果左方向返回true就符合继续return true 

但是递归返回false说明不符合 那就回退回溯  **回溯就把值加回来  然后向右便利递归**

向右的逻辑和向左的一样  如果依然没有返回true  说明整个都不符合 



**综上: 只有左便利  右便利**

---

```java
public boolean hasPathSum(Node root, int targetSum) {

    if(root == null) return false;  //空的直接返回false
    targetSum -= root.val;    // 做减法 
    if(root.l == null && root.r == null) return targetSum == 0;  

    if(root.l != null){
        boolean lv = hasPathSum(root.l, targetSum);
        if(lv) return true;
    }

    if(root.l != null){
        boolean rv = hasPathSum(root.r, targetSum);
        if(rv) return true;
    }
    return false;

}

```

为什么刚刚提到了回溯要加回来  但是代码没有写出呢?

**因为java中 基本数据类型是按值传递的,  ,  所以原始值不会变化**

---

### lc106从中序和后续便利构造二叉树
> <font style="color:rgb(44, 62, 80);">根据一棵树的中序遍历与后序遍历构造二叉树。  --- 中等</font>
>
> <font style="color:rgb(44, 62, 80);">注意: 你可以假设树中没有重复的元素。</font>
>

**<font style="color:rgb(44, 62, 80);">前序:  跟 左 右 		中序:  左 跟 右 		后序: 左 右 跟</font>**

---

中序是	9	**3**	15	20	7

后续是       9	15	7	20	**3**

1. 找根节点

**根据便利顺序 中序是左根右  后续是左右跟    后续的最后一个节点是跟  得出根节点是3**

2. 有跟之后看中序得出左右

找到根节点是3   那么看中序 根节点的前面就是左节点  也就是9     右节点是 15  20  7

3. 再看后续得孩子顺序

在后续剩余的是15  7   20  这三个 后续最后节点是跟 也就是20 是跟 

4. 再去看中序

最后的三个在中序的顺序是  15  20  7   已经找到20是跟  那么 15是左  7是右

**       3**

**      / \**

**     9   20**

**        /  \**

**       15   7**

---

**综上: 在代码顺序为**

1. 后序数组为0的话 说明是空节点
2. 找根 后序数组最后一个元素
3. 寻找中序数组跟的位置作为切割点
4. 切割中序数组 得出左右子树
5. 切割后续
6. 递归处理左右区间

---

然后递归三部曲

1. 返回类型是 根据中和后构造二叉树的节点  	参数是两个数组
2. 后续数组为0  说明是空节点 return null
3. 单层处理逻辑
+ 后续数组的最后一个元素就是根节点  构造出根节点
+ 找出根节点在中序数组的位置  int i = 0;  for(i = 0; i < 中序长度; i++ ) if(中[i] == rootV) break;   此时break之后只留下i 也就是根节点在中序数组的下标位置
+ 使用上一步的 i 切割中序  得出左右子树
+ 使用中序数组左区间大小 切后续的左区间   

注意:

 在切割中序数组  以及后续数组 注意区间

切割中序 使用i 也就是后序数组最后一个元素根节点在中序的位置

切中序  使用的是中序数组的左区间大小  切 后续的左区间

```plain
public class Lc106_buildTree {

    Map<Integer, Integer> m;  //用来快速定位中序遍历中节点的索引位置。

    public Node buildTree(int[] in, int[] post) {
        m = new HashMap<>();

        //用map保存中序序列的数值对应的位置
        for(int i = 0; i < in.length; i++) m.put(in[i], i);

        return findNode(in, 0, in.length, post, 0, post.length);

    }

    public Node findNode(int[] in, int inBegin, int inEnd, int[] post, int postBegin, int postEnd) {
        //左闭右开  如果不满足 说明是空的
        if(inBegin >= inEnd || postBegin >= postEnd) return null;
        // 后续数组的最后一个元素 就是根节点 然后构造出来
        int rootIndex = m.get(post[postEnd - 1]);
        Node root = new Node(in[rootIndex]);
        // 保存中序的左子树个数, 确定后续数组的个数
        int lLength = rootIndex - inBegin;

        root.l = findNode(in, inBegin, rootIndex, post, postBegin, postBegin + lLength);

        root.r = findNode(in, rootIndex + 1, inEnd, post, postBegin + lLength, postEnd - 1);

        return root;
    }
}

```

**注意本题的左右子树在中序和后序中的区间：**

    - **左子树：**
        * 中序区间：`[inBegin, rootIndex)`
        * 后序区间：`[postBegin, postBegin + lLength)`
    - **右子树：**
        * 中序区间：`[rootIndex + 1, inEnd)`
        * 后序区间：`[postBegin + lLength, postEnd - 1)`

---

### lc105_知道前序和中序构造二叉树
> 那么前序和中序能够构造二叉树吗?
>
> 前是跟左右   中是左跟右 
>
> 根据前序数组 第一个就是根节点  

>

```java
/**
 * lc105_找到前序和中序 还原二叉树 返回根节点
 */
public class Lc105_buildTreeQz {

    Map<Integer, Integer> m;

    public Node buildTree(int[] pre, int[] mid) {
        m = new HashMap<>();

        for(int i = 0; i < mid.length; i++) m.put(mid[i],i);

        return findNodeII(pre,0,pre.length,mid,0,mid.length);

    }

    private Node findNodeII(int[] pre, int preB, int preE, int[] mid, int midB, int midE) {
        if(preB >= preE || midB >= midE) return null;

        int rootIndex = m.get(pre[preB]);
        Node root = new Node(mid[rootIndex]);

        int lLen = rootIndex - midB;

        root.l = findNodeII(pre, preB + 1,preB + lLen + 1, mid, midB, rootIndex);

        root.r = findNodeII(pre, preB + lLen + 1, preE, mid, rootIndex + 1, midE);

        return root;

    }
}

```

**但是知道后续和前序 不能构造二叉树  因为 后续是左右跟 可以得出跟在哪   前序是跟左右  **

**关键是这俩左右是挨一块的  所以没办法分割区间**

---

# day17
### lc617_合并二叉树
> 给你两个二叉树  请你合并成一个二叉树  规则如下:
>
> 1. 如果在相同的位置有节点  那么两个节点相加
> 2. <font style="color:rgb(44, 62, 80);">不为 NULL 的节点将直接作为新二叉树的节点。</font>
>
> <font style="color:rgb(44, 62, 80);">注意: 合并必须从两个树的根节点开始。</font>
>



![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1732020446570-6ace4f58-8cdb-414f-a709-6e215d9ccc7c.png)



使用前序便利   跟 左  右



递归三部曲

1. 返回值 返回合并之后的根节点    参数:: 两个树的跟节点
2. 如果tree1遇到空 返回tree2  同理 t2遇到空 返回t1
3. 单层逻辑(直接改变t1)
+ 如果两个都不为空 那么两个节点相加
+  然后递归便利左子树  和 右子树

```java

public Node mergeTrees(Node r1, Node r2){
    if(r1 == null) return r2;
    if(r2 == null) return r1;

    r1.v += r2.v;

    r1.l = mergeTrees(r1.l, r2.l);
    r1.r = mergeTrees(r1.r, r2,r);

    return r1;
}
```

---

### lc654_构造最大的二叉树
> <font style="color:rgb(44, 62, 80);">给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</font>
>
> + <font style="color:rgb(44, 62, 80);">二叉树的根是数组中的最大元素。</font>
> + <font style="color:rgb(44, 62, 80);">左子树是通过数组中最大值左边部分构造出的最大二叉树。</font>
> + <font style="color:rgb(44, 62, 80);">右子树是通过数组中最大值右边部分构造出的最大二叉树。</font>
>
> <font style="color:rgb(44, 62, 80);">通过给定的数组构建最大二叉树，并且输出这个树的根节点。</font>
>

**凡是构造二叉树的题目 均要使用前序遍历 跟	左 	右**

---

假设给一个数组是 **3	2	1	6	0	5**

选择最大的元素6 作为跟节点  然后最大元素左区间继续构造左子树  规则还是一样 选取最大的作为跟节点   右区间同理

---

**递归三部曲**

1. **返回最大的跟节点	参数传入数组**
2. **如果数组大小等于1 说明到了叶子节点  那么就返回终止 new Node**
3. **单层逻辑 （跟 左 右)**
+ **找到最大值以及对应的下标 构造出跟节点**
+ **构造左子树  要保证区间里面元素最少有一个元素  左区间的范围 0 - 最大值index**
+ **右子树  范围是 index + 1 到 数组最后**
+ **返回跟节点**

---



```java
public Node constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) {
    return digui(nums, 0, nums.length);

}


private Node digui(int[] nums, int lIndex, int rIndex) {
    if(rIndex - lIndex < 1) return null;  //小于一说明没有元素了

    if(rIndex - lIndex == 1) return new Node(nums[lIndex]); // 说明只有一个元素

    int maxIndex = lIndex; //假设最大值的下标
    int maxVal = nums[maxIndex]; //假设最大值
    for(int i = lIndex + 1; i < rIndex; i++){ // 找最大值
        if(nums[i] > maxVal){
            maxVal = nums[i];
            maxIndex = i;

        }
    }
    Node root = new Node(maxVal);  //根据最大值构造跟节点
    root.l = digui(nums, lIndex, maxIndex);
    root.r = digui(nums, maxIndex + 1, rIndex);
    return root;

}

```

---

### lc700_二叉搜索数中的搜索
> <font style="color:rgb(44, 62, 80);">给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</font>
>



**二叉搜索树是什么？**

1. 如果左子树不为空， 则左子树上的所有节点的值 都小于 他的跟节点的值
2. 如果右子树不为空， 右子树上的所有节点上的值 都大于 他的跟节点
3. 他的左右子树 也分别上二叉搜索树

**跟节点大于左子树所有节点    小于右子树所有的节点**

---

本题根据这个规律 不用确定前中后便利顺序 根据规律就好

如果要搜索的值要是 小于 跟节点的值 说明要搜索的值 在左子树  就要去左子树去便利

大于  跟节点  说明在	右子树  就去右子树遍历

---

```java
public static Node searchBST(Node root, int target){
    if(root == null || root.v == target) return root;

    //如果要搜索的值要是 小于 跟节点的值 说明要搜索的值 在左子树
    //反之 在右子树
    if(target < root.v) return searchBST(root.l, target);
    else return searchBST(root.r, target);

}
```

---

### lc98_验证二叉搜索树
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个二叉树的根节点 </font>`<font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">root</font>`<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> ，判断其是否是一个有效的二叉搜索树。</font>
>
> <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">有效</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">二叉搜索树定义如下：</font>
>
> + <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">节点的左</font><font style="background-color:rgb(240, 240, 240);">子树</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">只包含</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">小于</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">当前节点的数。</font>
> + <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">节点的右子树只包含</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">大于</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">当前节点的数。</font>
> + <font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">所有左子树和右子树自身必须也是二叉搜索树。</font>
>

**<font style="color:#333333;">遇到 搜索树，一定想着中序遍历，这样才能利用上特性。  是不是单调递增的</font>**

**<font style="color:#333333;"></font>**

```java
package day17;


/**
 * 98. 验证二叉搜索树--中等
 *
 */
public class Lc98_isValidBST {
    Node max;


    public boolean isValidBST(Node root) {
        if(root == null) return true;

        //左
        boolean left = isValidBST(root.l);
        //跟
        if(max != null && root.v <= max.v) return false;
        max = root;
        //右
        boolean right = isValidBST(root.r);

        return right;
        
    }


}

```

---

# day18
### lc530_**<font style="color:#1a1a1a;">二叉搜索树的最小绝对差</font>**


> <font style="color:rgb(44, 62, 80);">给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意相邻两节点的差的绝对值的最小值。</font>
>
> <font style="color:#333333;"></font>
>
> <font style="color:#333333;">需要领悟一下二叉树遍历上双指针操作</font>
>

**提到二叉搜索树 在中序遍历 就是有序的**

最直观的想法 就是先中序遍历 转变成有序数组 然后再数组中再去求相邻两个元素的最小绝对差

**本题利用两个指针 直接得出绝对差  不转数组**

```java
public class Lc530_getMinimumDifference {

    Node pre;
    int res = Integer.MAX_VALUE;

    public int getMinimumDifference(Node root) {
        if(root == null) return 0;

        diGui(root);
        return res;
    }

    private void diGui(Node root) {
        if(root == null) return;
        //左
        diGui(root.l);
        //跟
        if(pre != null) res = Math.min(res, root.v - pre.v);
        pre = root;
        // 又
        diGui(root.r);

    }
    
}
```

**<font style="color:rgb(44, 62, 80);">遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。</font>**

---

### lc501_二叉搜索树的众数
> <font style="color:rgb(44, 62, 80);">给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</font>
>
> <font style="color:rgb(44, 62, 80);">假定 BST 有如下定义：</font>
>
> + <font style="color:rgb(44, 62, 80);">结点左子树中所含结点的值小于等于当前结点的值</font>
> + <font style="color:rgb(44, 62, 80);">结点右子树中所含结点的值大于等于当前结点的值</font>
> + <font style="color:rgb(44, 62, 80);">左子树和右子树都是二叉搜索树</font>
>

**<font style="color:rgb(44, 62, 80);">既然是二叉搜索树 那么他中序遍历就是有序的 小到大的顺序，  那么便利有序数组元素出现的频率 从头开始便利  那么一定是相邻两个元素做比较 因为是有序的   然后把出现频率最高的元素输出就可以了</font>**

---

> 跟节点处理逻辑：
>

使用双指针 pre = null   cur

一个指针指向前一个节点  这样每次当前节点才能和pre前一个节点进行比较  

<font style="color:rgb(44, 62, 80);">而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。count = 1</font>

**<font style="color:rgb(44, 62, 80);">如果pre == cur的时候 就统计count++ 这个count是单个元素出现的频率</font>**

**<font style="color:rgb(44, 62, 80);">如果！= cur 那么count重新初始化为1 只有相等的时候才会加count的值</font>**

****

**收集结果：**

如果count == maxCount的时候 就把这个元素放入res里面

<font style="color:rgb(44, 62, 80);">频率count 大于 maxCount的时候，不仅要更新maxCount = count ，而且要清空结果集res  ，因为结果集之前的元素都失效了。  然后把新的cur对应的val放入结果里面</font>

---

```java
package day18;

import java.util.ArrayList;

/**
 * lc501_.二叉搜索树中的众数
 * 系列详细代码请访问：https://github.com/WEIERHANG/leetcode
 */
public class Lc501_findMode {

    ArrayList<Integer> res; //结果
    int count, maxCount;  //当前出现频率， 最大频率
    Node pre;  //前一个节点

    public int[] findMode(Node root) {
        res = new ArrayList<>();
        maxCount = 0;
        count = 0;
        pre = null;
        findModeDiGui(root);
        // 转成结果数组并且返回
        int[] resArr = new int[res.size()];
        for(int i = 0; i < res.size(); i++) resArr[i] = res.get(i);
        return resArr;
    }

    private void findModeDiGui(Node root) {
        if (root == null) return;
        // 左
        findModeDiGui(root.l);
        // 根
        int rootVal = root.v;
        if(pre == null || rootVal != pre.v) count = 1;
        else count++;
        if(count > maxCount){
            res.clear();
            res.add(rootVal);
            maxCount = count;
        }else if(count == maxCount) res.add(rootVal);
        pre = root;

        // 右
        findModeDiGui(root.r);

    }

}

```

### lc236_二叉树的最近公共祖先
> <font style="color:rgb(44, 62, 80);">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</font>
>
> <font style="color:rgb(44, 62, 80);">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</font>
>

<font style="color:rgb(44, 62, 80);">本题需要从下往上进行查找 也就是回溯  二叉树的回溯过程 也就是下往上 返回给跟节点</font>

**<font style="color:rgb(44, 62, 80);">后序遍历（左右中）可以根据左右子树的返回值，来处理中节点的逻辑。</font>**

---

题目中 元素是唯一的   而且p  q都是一定会存在的 所以

<font style="color:rgb(44, 62, 80);">如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。</font>

<font style="color:rgb(44, 62, 80);"></font>

```java
   public Node lowestCommonAncestor(Node root, Node p, Node q) {

        if(root == null || root == p || root == q) return root;

        Node left = lowestCommonAncestor(root.l,p,q);
        Node right = lowestCommonAncestor(root.r, p, q);
        
        if(left == null && right == null) return null;  //没有找到
        else if(left == null && right != null) return right;
        else if(left != null && right == null) return left;  //找到一个
        else return root;  //找到两个

    }
```

---





---

------------

# day20
### lc235_<font style="color:rgb(44, 62, 80);">二叉搜索树的最近公共祖先</font>
> <font style="color:rgb(44, 62, 80);">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</font>
>
> <font style="color:rgb(44, 62, 80);">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</font>
>
> <font style="color:rgb(44, 62, 80);">例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</font>
>

---

<font style="color:rgb(44, 62, 80);">利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。</font>

<font style="color:rgb(44, 62, 80);">二叉搜索树是有序的,  因为是有序树，所以 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。即 中节点 > p && 中节点 < q 或者 中节点 > q && 中节点 < p。</font>

<font style="color:rgb(44, 62, 80);"></font>

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val) 
            return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val) 
            return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```





# day22_回溯算法
### 基础知识
> 回溯和递归是相辅相成的， 只要有递归 就会有回溯 通常在递归函数的下面出现递归
>
> 通常用于解决 组合问题     切割问题	子集问题 	 排列问题   棋盘问题(n皇后)
>



**组合 ： [1, 2] 和 【2， 1】是相同的组合  **

**排列： 【1，2】 和 【2,1】 是两个不同的排列 **



回溯法 其实是一个纯暴力的搜索算法

比如 给你1	2	3	4 在这里面找到大小为2的组合 那么组合分别是多少

切割问题：  给你一个字符串 问有几种切割方法  或者如何保证子串 都是回文子串 几种方式

---

**回溯法都可以抽象成n叉树结构**

树的宽度就是回溯法处理的集合的大小  使用for循环

树的深度就是递归的深度  因为递归一定是有终止的 一层一层向上返回



**回溯模版**

**一般来说 回溯的函数是没有返回值的  一般情况起名叫backtracking **

**参数的话 一般情况是非常多的 一次性无法完全确定**

<font style="color:rgb(44, 62, 80);">回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</font>

****

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1732344327063-ce30588f-9c68-48a8-af66-ab56af7a6e01.png)

```java
void backtracking(参数){
    if(终止条件){
        收集结果集;
        return;
    }
    for(选择：本层集合中元素（树中节点孩子的数量就是集合大小）){
        处理节点；
        backtracking(路径， 选择列表)；
        回溯，撤销处理结果；

    }

}
```

其中 for循环就是便利集合区间 ， 一个节点有多少孩子 这个for就执行多少多少次



---

### lc77_组合
> <font style="color:rgb(44, 62, 80);">给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</font>
>
> <font style="color:rgb(44, 62, 80);">示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</font>
>

此时 我们会想到一个非常非常普通暴力的解法  就是k=2的时候  使用两层for暴力

但是当k=40 50 60的情况下呢？  难道要写60个for？？  

---

**使用回溯算法**

回溯算法 其实就是通过递归来控制有多少for循环 递归里面的每一次其实就是一个for循环  

下一次递归就是下一层for循环

---

**回溯三部曲**

1. 确定递归函数的参数和返回值

一般情况 返回值都是void  极个别情况才会有返回值  函数名通常叫backtracking

2.  确定终止条件

到了叶子节点也就是路径大小为2的时候

3. 确定单层搜索逻辑

startIndex用来控制每个for循环从哪里开始的

下一层startIndex应该传入i + 1



```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        backtracking(n, k, 1, res, path);
        return res;        
    }
    public void backtracking(int n, int k, int sIndex, List<List<Integer>> res, List<Integer> path){
        if(path.size() == k){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = sIndex; i <= n; i++){
            path.add(i);
            backtracking(n, k, i + 1, res, path);
            path.remove(path.size() - 1); //移除最后一个
        }
    }
}
```

其中这个代码可以进行剪枝操作

<font style="color:rgb(44, 62, 80);">假设n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了</font>

<font style="color:rgb(44, 62, 80);">注意i，就是for循环里选择的起始位置。</font>

<font style="color:rgb(44, 62, 80);">接下来看一下优化过程如下：</font>

1. <font style="color:rgb(44, 62, 80);">已经选择的元素个数：path.size();</font>
2. <font style="color:rgb(44, 62, 80);">还需要的元素个数为: k - path.size();</font>
3. <font style="color:rgb(44, 62, 80);">在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</font>

<font style="color:rgb(44, 62, 80);">为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</font>

<font style="color:rgb(44, 62, 80);">举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。</font>

<font style="color:rgb(44, 62, 80);">从2开始搜索都是合理的，可以是组合[2, 3, 4]。</font>

<font style="color:rgb(44, 62, 80);">所以剪枝只需要控制for循环的范围就可以</font>

**<font style="color:rgb(44, 62, 80);">i <= n - (k - path.size()) + 1; </font>**

```java
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置
```

---

### lc216_组合总和III
> <font style="color:rgb(44, 62, 80);">找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</font>
>
> <font style="color:rgb(44, 62, 80);">说明：</font>
>
> + <font style="color:rgb(44, 62, 80);">所有数字都是正整数。</font>
> + <font style="color:rgb(44, 62, 80);">解集不能包含重复的组合。</font>
>
> <font style="color:rgb(44, 62, 80);">示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</font>
>
> <font style="color:rgb(44, 62, 80);">示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</font>
>

跟上一个题lc77的区别就是 本题给定了和的限制 让我们求和为n



```java
public List<List<Integer>> combinationSum3(int k, int n) {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    backtracking(k, n, 1, 0, res, path);
    return res;

}

private void backtracking(int k, int n, int sIndex, int sum, List<List<Integer>> res, List<Integer> path) {
    if(sum > n) return;
    if(path.size() == k){
        if(sum == n) res.add(new ArrayList<>(path));
        return;
    }
    for(int i = sIndex; i <= 9; i++){
        path.add(i);
        sum += i;
        backtracking(k, n, i + 1, sum, res, path);
        path.remove(path.size() - 1);
        sum -= i;
    }
}
```

剪枝：

** if(sum > n) return;**

**i <= 9 - (k - path.size()) + 1;**

---

### lc17_<font style="color:rgb(44, 62, 80);">电话号码的字母组合(手撕高频)</font>


> <font style="color:rgb(44, 62, 80);">给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</font>
>
> <font style="color:rgb(44, 62, 80);">给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</font>
>
> + <font style="color:rgb(44, 62, 80);">输入："23"</font>
> + <font style="color:rgb(44, 62, 80);">输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].</font>
>

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1732440623607-2a906084-29f5-45f3-9b26-dfbc9d6ed3ba.png)

首先要解决映射的问题，  数字2 对应 abc  数字3 对应def .....

**String[] numString  = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};**

<font style="color:rgb(44, 62, 80);">为什么要0和1也要呢  因为要对应下标 2就是对应abc </font>



---

<font style="color:rgb(44, 62, 80);">这个num是记录遍历第几个数字了，就是用来遍历digits的（题目中给出数字字符串），同时index也表示树的深度。</font>

<font style="color:rgb(44, 62, 80);">那么终止条件就是如果index 等于 输入的数字个数（digits.size）了（本来index就是用来遍历digits的）。 然后收集结果，结束本层递归。</font>

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        
        List<String> res = new ArrayList<>();
        StringBuilder path = new StringBuilder();

        if(digits == null || digits.length() == 0) return res;
        String[] numString = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        backtracking(digits, numString, 0, res, path); 
        return res;
    }
    public void backtracking(String d, String[] numString, int num, List<String> res, StringBuilder path){
        if(num == d.length()){
            res.add(path.toString());
            return;
        }
        String str = numString[d.charAt(num) - '0'];  // 获取当前数字的字母映射
        for(int i = 0; i < str.length(); i++){
            path.append(str.charAt(i));
            backtracking(d, numString, num + 1, res,path);
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

---

# day21
### lc39_组合总和
> <font style="color:rgb(44, 62, 80);">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</font>
>
> <font style="color:rgb(44, 62, 80);">candidates 中的数字可以无限制重复被选取。</font>
>
> <font style="color:rgb(44, 62, 80);">说明：</font>
>
> + <font style="color:rgb(44, 62, 80);">所有数字（包括 target）都是正整数。</font>
> + <font style="color:rgb(44, 62, 80);">解集不能包含重复的组合。</font>
>
> <font style="color:rgb(44, 62, 80);">示例 1：</font>
>
> + <font style="color:rgb(44, 62, 80);">输入：candidates = [2,3,6,7], target = 7,</font>
> + <font style="color:rgb(44, 62, 80);">所求解集为： [ [7], [2,2,3] ]</font>
>

<font style="color:rgb(44, 62, 80);">本题和lc77， lc216的区别是 本题没有数量要求 ,可以无限重复，但是有总和限制，所以间接来讲， 也是有个数限制</font>

---

构造出来的二叉树结构为：

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1732499803082-c2442678-7e06-4be1-827d-2db251d132ce.png)

**回溯三部曲**

1. **函数的参数和返回值**

void backtracking

参数：

list集合的res  存放结果集 

数组的path  存放符合条件的结果 

int的sum 来统计单一结果path里面的总和  

sIndex 用于控制for循环的起始位置 

**如果是一个集合来求组合 就需要sIndex   如果是多个集合取组合 各个集合不受影响就不需要**

2. **终止条件**

当得出的总和大于 目标值 就返回 没必要执行下去了  

当得出总和 == 目标  说明找到了符合条件的 返回结果

3. **单层回溯条件**

本题的单层for循环依旧sIndex开始  到arr的大小

注意可以重复 那就再调用递归时候 就不用i+1了 

剪枝操作 i < arr.size() && sum + arr[i] <= target

**<font style="color:rgb(44, 62, 80);">在求和问题中，排序之后加剪枝是常见的套路！</font>**



---

```java
public List<List<Integer>> combinationSum(int[] arr, int target){
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    Arrays.sort(arr); // 先进行排序 便于后面剪枝
    backtracking(arr,target,0,0,res,path);
    return res;
}

private void backtracking(int[] arr, int target, int sum, int sIndex, List<List<Integer>> res, List<Integer> path) {
    if(sum == target){
        res.add(new ArrayList<>(path));
        return;
    }
    for(int i = sIndex; i < arr.length; i++){
        sum += arr[i];
        if(sum > target) break;
        path.add(arr[i]);
        backtracking(arr,target,sum,i,res,path);
        sum -= arr[i];
        path.remove(path.size() - 1);
    }
}
```

---

### lc40_组合总和III
> <font style="color:rgb(44, 62, 80);">给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</font>
>
> <font style="color:rgb(44, 62, 80);">candidates 中的每个数字在每个组合中只能使用一次。</font>
>
> <font style="color:rgb(44, 62, 80);">说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。</font>
>

**<font style="color:rgb(44, 62, 80);">本题重点 : 1. 给定的集合（数组candidates）有重复元素，但结果集还不能有重复的组合。</font>**

**    2. ****<font style="color:rgb(44, 62, 80);">candidates 中的每个数字在每个组合中只能使用一次。</font>**

---

进行去重,**<font style="color:rgb(44, 62, 80);">所谓去重，其实就是使用过的元素不能重复选取</font>**

**<font style="color:rgb(44, 62, 80);">使用过的有两种 1.是同一树枝上使用过的</font>**

2, 同一树层使用过的 (需要先进行排序,目的相邻的两个在一起)

回看本题要求:  元素在同一组合内可以重复  但是两个组合不能相同  所以要去重的是同一树层



那么<font style="color:rgb(44, 62, 80);">如何判断同一树层上元素（相同的元素）是否使用过了呢。</font>

**<font style="color:rgb(44, 62, 80);">如果</font>**`**<font style="color:rgb(71, 101, 130);">candidates[i] == candidates[i - 1]</font>**`**<font style="color:rgb(44, 62, 80);"> 并且 </font>**`**<font style="color:rgb(71, 101, 130);">used[i - 1] == false</font>**`**<font style="color:rgb(44, 62, 80);">，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]</font>**<font style="color:rgb(44, 62, 80);">。  </font><font style="color:rgb(44, 62, 80);">此时for循环里就应该做continue的操作。</font>

---

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        boolean[] used = new boolean[candidates.length]; // 是否使用过
        Arrays.fill(used, false); // 初始化 快速填充used数组
        Arrays.sort(candidates); // 对数组排序，方便去重
        backtracking(candidates, target, 0, 0, res, path, used);
        return res;
    }

    public void backtracking(int[] arr, int target, int sum, int startIndex, 
                             List<List<Integer>> res, List<Integer> path, boolean[] used) {
        // 如果找到一个组合，则添加到结果集中
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return; // 结束当前递归分支
        }

        for (int i = startIndex; i < arr.length; i++) {
            // 剪枝操作：如果当前数字加起来超过 target，则无需继续
            if (sum + arr[i] > target) break;

            // 去重：跳过同层的重复元素
            if (i > 0 && arr[i] == arr[i - 1] && !used[i - 1]) continue;

            // 选择当前数字
            used[i] = true;
            sum += arr[i];
            path.add(arr[i]);

            // 递归到下一层，注意从下一个位置开始
            backtracking(arr, target, sum, i + 1, res, path, used);

            // 回溯：
            used[i] = false;
            sum -= arr[i];
            path.remove(path.size() - 1);
        }
    }
}
```

**<font style="color:rgb(44, 62, 80);">本题也可以不借助used数组 仅仅使用startIndex来控制去重</font>**

```java
class Solution {

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>(); 
        List<Integer> path = new ArrayList<>();       
        int sum = 0;                                

        // 排序，方便去重
        Arrays.sort(candidates);

        // 调用回溯函数
        backTracking(candidates, target, 0, res, path, sum);
        return res;
    }

    private void backTracking(int[] candidates, int target, int start, 
                              List<List<Integer>> res, List<Integer> path, int sum) {
        if (sum == target) {
            // 如果路径的和等于目标值，保存当前路径
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i < candidates.length && sum + candidates[i] <= target; i++) {
            // 去重：跳过同一树层中相同的数字
            if (i > start && candidates[i] == candidates[i - 1]) continue;
            
            // 选择当前数字
            sum += candidates[i];
            path.add(candidates[i]);

            // 递归，进入下一层，`i + 1` 表示当前数字只能用一次
            backTracking(candidates, target, i + 1, res, path, sum);

            // 回溯，撤销选择
            sum -= candidates[i];
            path.remove(path.size() - 1);
        }
    }
}

```

---

### lc131_分割回文串
> <font style="color:rgb(44, 62, 80);">给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</font>
>
> <font style="color:rgb(44, 62, 80);">返回 s 所有可能的分割方案。</font>
>
> <font style="color:rgb(44, 62, 80);">示例: 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ]</font>
>

回文串: 是向前和向后读都相同的字符串。 

分割的过程 和 回溯法的选取元素的过程类似  分割的区间组成了子串

![](https://cdn.nlark.com/yuque/0/2024/png/26344032/1732520236474-46aeb590-c8e1-45f2-9822-b0a989bdc615.png)

子串的范围: (startIndex, i]   因为sIndex是固定的 但是i是不断的加加的  所以表示范围



**<font style="color:rgb(44, 62, 80);">几个难点：</font>**

+ <font style="color:rgb(44, 62, 80);">切割问题可以抽象为组合问题</font>
+ <font style="color:rgb(44, 62, 80);">如何模拟切割线</font>

<font style="color:rgb(44, 62, 80);">startIndex就是切割线</font>

+ <font style="color:rgb(44, 62, 80);">切割问题中递归如何终止</font>

<font style="color:rgb(44, 62, 80);">切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止条件。</font>

+ <font style="color:rgb(44, 62, 80);">在递归循环中如何截取子串</font>

<font style="color:rgb(44, 62, 80);">在</font>`<font style="color:rgb(71, 101, 130);">for (int i = startIndex; i < s.size(); i++)</font>`<font style="color:rgb(44, 62, 80);">循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。</font>

<font style="color:rgb(44, 62, 80);">首先判断这个子串是不是回文，如果是回文，就加入</font>`<font style="color:rgb(71, 101, 130);">path</font>`<font style="color:rgb(44, 62, 80);">中，path用来记录切割过的回文子串。</font>

+ <font style="color:rgb(44, 62, 80);">如何判断回文</font>

判断是否为回文子串: <font style="color:rgb(44, 62, 80);">使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。</font>

<font style="color:rgb(44, 62, 80);"></font>

<font style="color:rgb(44, 62, 80);"></font>

```java
public List<List<String>> partition(String s) {
    List<List<String>> res = new ArrayList<>();
    List<String> path = new ArrayList<>();
    backtracking(s, path, res, 0);
    return res;
}

private void backtracking(String s, List<String> path, List<List<String>> res, int sIndex) {
    if(sIndex == s.length()){
        res.add(new ArrayList<>(path));
        return;
    }
    StringBuilder sb = new StringBuilder(); // 用于判断是否回文
    for(int i = sIndex; i < s.length(); i++){
        sb.append(s.charAt(i));
        if(check(sb)){   // 如果是回文 就收集起来
            path.add(sb.toString());
            backtracking(s, path, res, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
// 双指针判断是否为回文子串
public boolean check(StringBuilder sb){
    for(int i = 0; i < sb.length(); i++){
        if(sb.charAt(i) != sb.charAt(sb.length() - 1 - i)) return false;
    }
    return true;
}
```

